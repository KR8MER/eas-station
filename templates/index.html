{% extends "base.html" %}

{% block title %}Interactive Map - KR8MER CAP Emergency Alert System{% endblock %}

{% block extra_css %}
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />

<style>
    #map {
        height: 600px;
        width: 100%;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        box-shadow: 0 2px 10px var(--shadow-color);
    }

    .map-controls {
        background: var(--bg-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 2px 10px var(--shadow-color);
    }

    .status-panel {
        background: var(--bg-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 2px 10px var(--shadow-color);
    }

    .status-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        padding: 5px 0;
        border-bottom: 1px solid var(--border-color);
    }

    .status-item:last-child {
        border-bottom: none;
    }

    .status-value {
        font-weight: 600;
        color: var(--primary-color);
    }

    .alert-summary {
        background: var(--light-color);
        border-radius: 5px;
        padding: 15px;
        margin-top: 15px;
    }

    .layer-group {
        margin-bottom: 15px;
    }

    .layer-group h6 {
        color: var(--text-color);
        margin-bottom: 10px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .form-check {
        margin-bottom: 8px;
    }

    .layer-options {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .layer-swatch {
        display: inline-block;
        width: 14px;
        height: 14px;
        border-radius: 3px;
        border: 1px solid var(--border-color);
    }

    .layer-options .form-check-label {
        display: flex;
        align-items: center;
        gap: 8px;
        width: 100%;
    }

    .layer-options .form-check-label .ms-auto {
        margin-left: auto;
    }

    .layer-options .empty-placeholder {
        font-style: italic;
        color: var(--secondary-color);
        font-size: 0.9rem;
    }

    .form-check-input:checked {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
    }

    .legend {
        background: var(--bg-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        margin-top: 20px;
    }

    .legend h6 {
        color: var(--primary-color);
        margin-bottom: 15px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
    }

    .legend-dynamic {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        margin-right: 10px;
        border: 1px solid var(--border-color);
    }

    .loading-message {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 600px;
        color: var(--secondary-color);
        flex-direction: column;
        background: var(--light-color);
        border-radius: 8px;
        border: 1px solid var(--border-color);
    }

    .spinner {
        border: 3px solid var(--border-color);
        border-top: 3px solid var(--primary-color);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .map-error {
        text-align: center;
        color: var(--danger-color);
        padding: 40px;
        background: var(--light-color);
        border-radius: 8px;
        border: 1px solid var(--danger-color);
    }

    .historical-badge {
        background: linear-gradient(45deg, #6c757d, #495057);
        color: white;
        font-size: 0.7em;
        padding: 2px 6px;
        border-radius: 8px;
        margin-left: 5px;
    }

    #date-filters {
        background: var(--light-color);
        border-radius: 6px;
        padding: 15px;
        border: 1px solid var(--border-color);
        margin-top: 10px;
    }

    .btn-outline-success:hover {
        background-color: var(--success-color);
        border-color: var(--success-color);
    }

    .btn-outline-primary:hover {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
    }

    .alert-active {
        border: 2px solid var(--danger-color) !important;
        background-color: rgba(220, 53, 69, 0.1) !important;
    }

    .alert-expired {
        border: 2px solid var(--secondary-color) !important;
        background-color: rgba(108, 117, 125, 0.1) !important;
        opacity: 0.7;
    }

    /* Leaflet popup customization */
    .leaflet-popup-content {
        max-width: 300px;
    }

    .popup-title {
        font-weight: bold;
        color: var(--primary-color);
        margin-bottom: 8px;
        font-size: 1.1em;
    }

    .popup-detail {
        margin-bottom: 5px;
        font-size: 0.9em;
    }

    .popup-badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.8em;
        font-weight: 600;
        margin: 2px;
    }

    .severity-extreme { background: #dc3545; color: white; }
    .severity-severe { background: #fd7e14; color: white; }
    .severity-moderate { background: #ffc107; color: black; }
    .severity-minor { background: #17a2b8; color: white; }
    .severity-unknown { background: #6c757d; color: white; }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-3">
    <div class="row">
        <!-- Control Panel -->
        <div class="col-md-3">
            <!-- Map Controls -->
            <div class="status-panel">
                <h5 class="mb-3">
                    <i class="fas fa-layer-group"></i> Map Layers
                </h5>

                <!-- Alert Layers -->
                <div class="layer-group">
                    <h6><i class="fas fa-exclamation-triangle"></i> Alert Types</h6>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="show-active" checked>
                        <label class="form-check-label" for="show-active">
                            <i class="fas fa-circle text-danger"></i> Active Alerts
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="show-expired">
                        <label class="form-check-label" for="show-expired">
                            <i class="fas fa-circle text-secondary"></i> Historical Alerts
                        </label>
                    </div>
                </div>

                <!-- Boundary Layers -->
                <div class="layer-group">
                    <h6><i class="fas fa-map-marked-alt"></i> Geographic Boundaries</h6>
                    <div id="layer-group-geographic" class="layer-options"></div>
                </div>

                <!-- Service Boundaries -->
                <div class="layer-group">
                    <h6><i class="fas fa-shield-alt"></i> Service Boundaries</h6>
                    <div id="layer-group-service" class="layer-options"></div>
                </div>

                <!-- Infrastructure Boundaries -->
                <div class="layer-group">
                    <h6><i class="fas fa-tools"></i> Infrastructure</h6>
                    <div id="layer-group-infrastructure" class="layer-options"></div>
                </div>

                <!-- Water Features -->
                <div class="layer-group">
                    <h6><i class="fas fa-water"></i> Water Features</h6>
                    <div id="layer-group-hydrography" class="layer-options"></div>
                </div>

                <!-- Custom Layers -->
                <div class="layer-group">
                    <h6><i class="fas fa-layer-group"></i> Custom Layers</h6>
                    <div id="layer-group-custom" class="layer-options"></div>
                </div>

                <!-- Date Filters for Historical -->
                <div id="date-filters" style="display: none;">
                    <h6><i class="fas fa-calendar-alt"></i> Date Range</h6>
                    <div class="mb-2">
                        <label for="start-date" class="form-label small">From:</label>
                        <input type="date" class="form-control form-control-sm" id="start-date">
                    </div>
                    <div class="mb-2">
                        <label for="end-date" class="form-label small">To:</label>
                        <input type="date" class="form-control form-control-sm" id="end-date">
                    </div>
                    <button class="btn btn-primary btn-sm w-100" onclick="loadHistoricalAlerts()">
                        <i class="fas fa-search"></i> Apply Filter
                    </button>
                </div>
            </div>

            <!-- System Status -->
            <div class="status-panel">
                <h5 class="mb-3">
                    <i class="fas fa-info-circle"></i> System Status
                </h5>
                <div class="status-item">
                    <span><i class="fas fa-exclamation-triangle"></i> Active Alerts:</span>
                    <span class="status-value" id="active-alert-count">Loading...</span>
                </div>
                <div class="status-item">
                    <span><i class="fas fa-map-marked"></i> Boundaries:</span>
                    <span class="status-value" id="boundary-count">Loading...</span>
                </div>
                <div class="status-item">
                    <span><i class="fas fa-clock"></i> Last Update:</span>
                    <span class="status-value" id="last-update">Loading...</span>
                </div>
                <div class="status-item">
                    <span><i class="fas fa-map"></i> Map Status:</span>
                    <span class="status-value" id="map-status">Initializing...</span>
                </div>

                <div id="alert-summary" class="alert-summary" style="display: none;">
                    <!-- Alert summary will be populated by JavaScript -->
                </div>
            </div>

            <!-- Quick Actions -->
            <div class="status-panel">
                <h5 class="mb-3">
                    <i class="fas fa-bolt"></i> Quick Actions
                </h5>
                <div class="d-grid gap-2">
                    <button class="btn btn-outline-success btn-sm" onclick="refreshData()">
                        <i class="fas fa-sync-alt" id="refresh-icon"></i> Refresh Map
                    </button>
                    <a href="/alerts" class="btn btn-outline-primary btn-sm">
                        <i class="fas fa-history"></i> View History
                    </a>
                    <a href="{{ url_for('audio_history') }}" class="btn btn-outline-warning btn-sm">
                        <i class="fas fa-headphones"></i> Audio Archive
                    </a>
                    <a href="/stats" class="btn btn-outline-info btn-sm">
                        <i class="fas fa-chart-bar"></i> Statistics
                    </a>
                    <a href="/admin" class="btn btn-outline-secondary btn-sm">
                        <i class="fas fa-cog"></i> Admin Panel
                    </a>
                    <button class="btn btn-outline-warning btn-sm" onclick="centerOnConfiguredLocation()">
                        <i class="fas fa-crosshairs"></i> Center on {{ location_settings.county_name }}
                    </button>
                    <button class="btn btn-outline-info btn-sm" onclick="inspectBoundaries()">
                        <i class="fas fa-search"></i> Inspect Boundaries
                    </button>
                </div>
            </div>
        </div>

        <!-- Map Column -->
        <div class="col-md-9">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-map"></i> Interactive Emergency Alert Map
                        <span class="badge bg-success ms-2" id="map-status-badge">Loading...</span>
                    </h5>
                </div>
                <div class="card-body p-0">
                    <div id="map">
                        <div class="loading-message">
                            <div class="spinner"></div>
                            <div><strong>Loading Interactive Map...</strong></div>
                            <div class="text-muted">Initializing Leaflet map for {{ location_settings.county_name }}, {{ location_settings.state_code }}</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Map Legend -->
            <div class="legend">
                <h6><i class="fas fa-list"></i> Map Legend</h6>
                <div class="row">
                    <div class="col-md-4">
                        <strong>Alert Severity:</strong>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #dc3545;"></div>
                            <span>Extreme</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #fd7e14;"></div>
                            <span>Severe</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #ffc107;"></div>
                            <span>Moderate</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #17a2b8;"></div>
                            <span>Minor</span>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <strong>Alert Status:</strong>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #28a745;"></div>
                            <span>Active Alerts</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: repeating-linear-gradient(45deg, #6c757d, #6c757d 3px, transparent 3px, transparent 6px);"></div>
                            <span>Historical Alerts</span>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <strong>Boundaries & Layers:</strong>
                        <div id="legend-boundary-layers" class="legend-dynamic"></div>
                        <div id="legend-boundary-empty" class="text-muted small">Layers will appear when data is loaded.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<!-- Load Leaflet -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>

<script>
console.log('🗺️ Interactive map page initializing...');

// Global map variables
let map;
let alertLayer;
let boundaryLayers = {};
let alertData = { active: [], historical: [] };

const BOUNDARY_TYPE_CONFIG = window.BOUNDARY_TYPE_CONFIG || {};
const BOUNDARY_GROUP_LABELS = window.BOUNDARY_GROUP_LABELS || {};
const CUSTOM_BOUNDARY_PALETTE = ['#38bdf8', '#fb7185', '#845ef7', '#22c55e', '#f97316', '#14b8a6', '#facc15', '#64748b'];
const boundaryTypeMetadata = new Map();
const layerVisibility = {};
const customColorAssignments = {};

const LOCATION_SETTINGS = window.APP_LOCATION || {};
const MAP_CENTER = [
    Number(LOCATION_SETTINGS.map_center_lat ?? 0) || 0,
    Number(LOCATION_SETTINGS.map_center_lng ?? 0) || 0
];
const MAP_ZOOM = Number(LOCATION_SETTINGS.map_default_zoom ?? 10) || 10;
const LOCATION_LABEL = `${(LOCATION_SETTINGS.county_name || 'Configured Location')}${LOCATION_SETTINGS.state_code ? ', ' + LOCATION_SETTINGS.state_code : ''}`;

// Boundary helpers
function sanitizeBoundaryType(value) {
    if (!value) {
        return 'unknown';
    }
    const sanitized = value.toString().trim().toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/_+/g, '_').replace(/^_+|_+$/g, '');
    return sanitized || 'unknown';
}

function resolveCanonicalBoundaryType(value) {
    const sanitized = sanitizeBoundaryType(value);
    for (const [key, config] of Object.entries(BOUNDARY_TYPE_CONFIG)) {
        const aliases = Array.isArray(config.aliases) ? config.aliases.map(alias => sanitizeBoundaryType(alias)) : [];
        if (sanitized === key || aliases.includes(sanitized)) {
            return key;
        }
    }
    return sanitized;
}

function formatBoundaryLabel(type) {
    const canonical = resolveCanonicalBoundaryType(type);
    const config = BOUNDARY_TYPE_CONFIG[canonical];
    if (config && config.label) {
        return config.label;
    }
    if (!canonical || canonical === 'unknown') {
        return 'Unknown Boundary';
    }
    return canonical.replace(/_/g, ' ').replace(/\b\w/g, char => char.toUpperCase());
}

function assignCustomColor(typeKey) {
    if (customColorAssignments[typeKey]) {
        return customColorAssignments[typeKey];
    }
    const hash = Array.from(typeKey).reduce((acc, char) => acc + char.charCodeAt(0), 0);
    const color = CUSTOM_BOUNDARY_PALETTE[hash % CUSTOM_BOUNDARY_PALETTE.length];
    customColorAssignments[typeKey] = color;
    return color;
}

function getBoundaryMetadata(rawType, displayType, colorHint) {
    const canonical = resolveCanonicalBoundaryType(rawType);
    const config = BOUNDARY_TYPE_CONFIG[canonical];
    const label = displayType || (config && config.label) || formatBoundaryLabel(canonical);
    const group = config && config.group ? config.group : 'custom';
    const color = colorHint || (config && config.color) || assignCustomColor(canonical || 'custom');

    return {
        key: canonical,
        label,
        group,
        color,
        rawType: rawType,
    };
}

// Map initialization
function initMap() {
    try {
        console.log(`🗺️ Initializing Leaflet map for ${LOCATION_LABEL}...`);

        // Create map centered on configured location
        map = L.map('map').setView(MAP_CENTER, MAP_ZOOM);

        // Add OpenStreetMap tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 18,
            minZoom: 8
        }).addTo(map);

        // Initialize layer groups
        alertLayer = L.layerGroup().addTo(map);
        boundaryLayers = {};

        // Add scale control
        L.control.scale({
            position: 'bottomleft'
        }).addTo(map);

        console.log('✅ Map initialized successfully');
        updateMapStatus('Ready', 'success');

        // Load initial data
        loadAlerts();
        loadBoundaries();
        updateSystemStatus();

        // Set up event listeners
        setupEventListeners();

    } catch (error) {
        console.error('❌ Error initializing map:', error);
        showMapError('Failed to initialize map: ' + error.message);
        updateMapStatus('Error', 'danger');
    }
}

// Load alerts from API
async function loadAlerts() {
    try {
        console.log('📡 Loading alerts from API...');
        const response = await fetch('/api/alerts');

        if (!response.ok) {
            throw new Error(`API responded with status: ${response.status}`);
        }

        const data = await response.json();

        if (response.ok && data.features) {
            alertData.active = data.features;
            displayAlerts(data.features);
            updateAlertCount(data.features.length);
            updateAlertSummary(data.features);
            console.log(`✅ Loaded ${data.features.length} alerts`);

            // Debug: Log the structure of the first alert if available
            if (data.features.length > 0) {
                console.log('📋 Sample alert structure:', data.features[0]);
            }
        } else {
            console.warn('⚠️ No alert features in API response:', data);
            updateAlertCount(0);
        }
    } catch (error) {
        console.error('❌ Error loading alerts:', error);
        showToast('Failed to load alerts: ' + error.message, 'error');
        updateAlertCount(0);
    }
}

// Load historical alerts
async function loadHistoricalAlerts() {
    const startDate = document.getElementById('start-date').value;
    const endDate = document.getElementById('end-date').value;

    if (!startDate || !endDate) {
        showToast('Please select both start and end dates', 'warning');
        return;
    }

    try {
        const response = await fetch(`/api/alerts/historical?start=${startDate}&end=${endDate}`);
        const data = await response.json();

        if (response.ok && data.features) {
            alertData.historical = data.features;
            if (document.getElementById('show-expired').checked) {
                displayHistoricalAlerts(data.features);
            }
            showToast(`Loaded ${data.features.length} historical alerts`, 'success');
        }
    } catch (error) {
        console.error('❌ Error loading historical alerts:', error);
        showToast('Failed to load historical alerts: ' + error.message, 'error');
    }
}

// Display alerts on map
function displayAlerts(alerts) {
    alertLayer.clearLayers();

    if (!alerts || alerts.length === 0) {
        console.log('ℹ️ No alerts to display');
        return;
    }

    alerts.forEach(alert => {
        if (alert.geometry) {
            const severity = alert.properties.severity || 'Unknown';
            const color = getSeverityColor(severity);
            const isActive = !isAlertExpired(alert.properties.expires);

            const alertFeature = L.geoJSON(alert, {
                style: {
                    color: color,
                    weight: alert.properties.is_county_wide ? 4 : 3,
                    opacity: isActive ? 0.8 : 0.5,
                    fillOpacity: alert.properties.is_county_wide ? 0.3 : 0.4,
                    fillColor: color,
                    dashArray: alert.properties.is_county_wide ? '10,5' : null,
                    className: isActive ? 'alert-active' : 'alert-expired'
                },
                onEachFeature: function(feature, layer) {
                    const props = feature.properties;
                    const popupContent = createAlertPopup(props);
                    layer.bindPopup(popupContent, { maxWidth: 300 });
                }
            });

            alertLayer.addLayer(alertFeature);
        }
    });

    console.log(`✅ Displayed ${alerts.length} alerts on map`);
}

// Display historical alerts
function displayHistoricalAlerts(alerts) {
    alerts.forEach(alert => {
        if (alert.geometry) {
            const alertFeature = L.geoJSON(alert, {
                style: {
                    color: '#6c757d',
                    weight: 2,
                    opacity: 0.6,
                    fillOpacity: 0.1,
                    fillColor: '#6c757d',
                    dashArray: '5,5',
                    className: 'alert-expired'
                },
                onEachFeature: function(feature, layer) {
                    const props = feature.properties;
                    const popupContent = createHistoricalAlertPopup(props);
                    layer.bindPopup(popupContent, { maxWidth: 300 });
                }
            });

            alertLayer.addLayer(alertFeature);
        }
    });
}

// Load boundaries
async function loadBoundaries() {
    try {
        console.log('📡 Loading boundaries from API...');
        const response = await fetch('/api/boundaries');

        if (!response.ok) {
            throw new Error(`API responded with status: ${response.status}`);
        }

        const data = await response.json();
        const newKeys = new Set();
        let totalLoaded = 0;
        boundaryTypeMetadata.clear();

        if (data.features && Array.isArray(data.features) && data.features.length > 0) {
            console.log(`✅ Received ${data.features.length} boundaries`);

            const featuresByType = new Map();

            data.features.forEach(feature => {
                const props = feature.properties || {};
                const rawType = props.canonical_type || props.type || props.raw_type || 'unknown';
                const metadata = getBoundaryMetadata(rawType, props.display_type, props.color);
                const typeKey = metadata.key || 'unknown';

                if (!featuresByType.has(typeKey)) {
                    featuresByType.set(typeKey, { metadata, features: [] });
                }
                featuresByType.get(typeKey).features.push(feature);
            });

            featuresByType.forEach(({ metadata, features }) => {
                const typeKey = metadata.key || 'unknown';
                newKeys.add(typeKey);
                totalLoaded += features.length;

                let layerGroup = boundaryLayers[typeKey];
                if (!layerGroup) {
                    layerGroup = L.layerGroup();
                    boundaryLayers[typeKey] = layerGroup;
                } else {
                    layerGroup.clearLayers();
                }

                const boundaryFeature = L.geoJSON(features, {
                    style: {
                        color: metadata.color,
                        weight: 1,
                        opacity: 0.6,
                        fillOpacity: 0.1,
                        fillColor: metadata.color
                    },
                    onEachFeature: function(feature, layer) {
                        const props = feature.properties || {};
                        const popupContent = createBoundaryPopup(props, typeKey);
                        layer.bindPopup(popupContent);
                    }
                });

                layerGroup.addLayer(boundaryFeature);

                if (layerVisibility[typeKey] !== false) {
                    layerVisibility[typeKey] = true;
                    layerGroup.addTo(map);
                } else {
                    map.removeLayer(layerGroup);
                }

                boundaryTypeMetadata.set(typeKey, {
                    key: typeKey,
                    label: metadata.label,
                    color: metadata.color,
                    group: metadata.group || 'custom',
                    count: features.length
                });

                console.log(`✅ Loaded ${features.length} ${metadata.label} features`);
            });
        } else {
            console.warn('⚠️ No boundary features in API response');
        }

        Object.keys(boundaryLayers).forEach(key => {
            if (!newKeys.has(key)) {
                map.removeLayer(boundaryLayers[key]);
                delete boundaryLayers[key];
                boundaryTypeMetadata.delete(key);
                delete layerVisibility[key];
            }
        });

        renderBoundaryControls();
        renderBoundaryLegend();
        updateBoundaryCount(totalLoaded);
    } catch (error) {
        console.error('❌ Error loading boundaries:', error);
        showToast('Failed to load boundaries: ' + error.message, 'error');
        updateBoundaryCount(0);
        boundaryTypeMetadata.clear();
        renderBoundaryControls();
        renderBoundaryLegend();
    }
}

function renderBoundaryControls() {
    const containers = {
        geographic: document.getElementById('layer-group-geographic'),
        service: document.getElementById('layer-group-service'),
        infrastructure: document.getElementById('layer-group-infrastructure'),
        hydrography: document.getElementById('layer-group-hydrography'),
        custom: document.getElementById('layer-group-custom')
    };

    Object.values(containers).forEach(container => {
        if (container) {
            container.innerHTML = '';
        }
    });

    const entries = Array.from(boundaryTypeMetadata.values()).sort((a, b) => a.label.localeCompare(b.label));

    entries.forEach(meta => {
        const groupKey = containers[meta.group] ? meta.group : 'custom';
        const container = containers[groupKey] || containers.custom;
        if (!container) {
            return;
        }

        const checkboxId = `layer-toggle-${meta.key}`;
        const isChecked = layerVisibility[meta.key] !== false;

        const wrapper = document.createElement('div');
        wrapper.className = 'form-check';

        const checkbox = document.createElement('input');
        checkbox.className = 'form-check-input';
        checkbox.type = 'checkbox';
        checkbox.id = checkboxId;
        checkbox.checked = isChecked;

        const label = document.createElement('label');
        label.className = 'form-check-label';
        label.setAttribute('for', checkboxId);

        const swatch = document.createElement('span');
        swatch.className = 'layer-swatch';
        swatch.style.backgroundColor = meta.color;

        const labelText = document.createElement('span');
        labelText.textContent = meta.label;

        const countWrapper = document.createElement('span');
        countWrapper.className = 'ms-auto text-muted small';
        countWrapper.innerHTML = `(<span data-type-count="${meta.key}">${meta.count}</span>)`;

        label.appendChild(swatch);
        label.appendChild(labelText);
        label.appendChild(countWrapper);

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        container.appendChild(wrapper);

        checkbox.addEventListener('change', function() {
            layerVisibility[meta.key] = this.checked;
            if (this.checked) {
                if (boundaryLayers[meta.key]) {
                    boundaryLayers[meta.key].addTo(map);
                }
            } else if (boundaryLayers[meta.key]) {
                map.removeLayer(boundaryLayers[meta.key]);
            }
        });
    });

    Object.entries(containers).forEach(([groupKey, container]) => {
        if (!container) {
            return;
        }

        if (!container.children.length) {
            const empty = document.createElement('div');
            empty.className = 'empty-placeholder';
            const groupLabel = BOUNDARY_GROUP_LABELS[groupKey] || 'Layers';
            const labelText = typeof groupLabel === 'string' ? groupLabel.toLowerCase() : 'layers';
            empty.textContent = `No ${labelText} loaded`;
            container.appendChild(empty);
        }
    });
}

function renderBoundaryLegend() {
    const container = document.getElementById('legend-boundary-layers');
    const emptyMessage = document.getElementById('legend-boundary-empty');

    if (!container || !emptyMessage) {
        return;
    }

    container.innerHTML = '';

    const entries = Array.from(boundaryTypeMetadata.values())
        .filter(meta => meta.count > 0)
        .sort((a, b) => a.label.localeCompare(b.label));

    if (entries.length === 0) {
        emptyMessage.style.display = 'block';
        return;
    }

    emptyMessage.style.display = 'none';

    entries.forEach(meta => {
        const item = document.createElement('div');
        item.className = 'legend-item';

        const swatch = document.createElement('div');
        swatch.className = 'legend-color';
        swatch.style.backgroundColor = meta.color;

        const label = document.createElement('span');
        label.textContent = `${meta.label} (${meta.count})`;

        item.appendChild(swatch);
        item.appendChild(label);
        container.appendChild(item);
    });
}

// Create alert popup content
function createAlertPopup(props) {
    const severityClass = `severity-${(props.severity || 'unknown').toLowerCase()}`;
    const isActive = !isAlertExpired(props.expires);
    const statusBadge = isActive ?
        '<span class="popup-badge" style="background: #28a745; color: white;">ACTIVE</span>' :
        '<span class="popup-badge" style="background: #6c757d; color: white;">EXPIRED</span>';

    return `
        <div class="popup-title">${props.event || 'Unknown Event'}</div>
        <div class="popup-detail">
            <span class="popup-badge ${severityClass}">${props.severity || 'Unknown'}</span>
            ${statusBadge}
            ${props.is_county_wide ? '<span class="popup-badge" style="background: #17a2b8; color: white;">COUNTY-WIDE</span>' : ''}
        </div>
        <div class="popup-detail"><strong>Area:</strong> ${props.area_desc || 'Unknown'}</div>
        <div class="popup-detail"><strong>Effective:</strong> ${props.effective ? new Date(props.effective).toLocaleString() : 'Unknown'}</div>
        <div class="popup-detail"><strong>Expires:</strong> ${props.expires ? new Date(props.expires).toLocaleString() : 'Unknown'}</div>
        ${props.headline ? `<div class="popup-detail"><strong>Headline:</strong> ${props.headline}</div>` : ''}
        <div class="mt-2">
            <a href="/alerts/${props.id}" class="btn btn-sm btn-primary">View Details</a>
        </div>
    `;
}

// Create historical alert popup content
function createHistoricalAlertPopup(props) {
    return `
        <div class="popup-title">
            ${props.event || 'Unknown Event'}
            <span class="historical-badge">Historical</span>
        </div>
        <div class="popup-detail"><strong>Severity:</strong> ${props.severity || 'Unknown'}</div>
        <div class="popup-detail"><strong>Area:</strong> ${props.area_desc || 'Unknown'}</div>
        <div class="popup-detail"><strong>Date:</strong> ${props.effective ? new Date(props.effective).toLocaleDateString() : 'Unknown'}</div>
        <div class="mt-2">
            <a href="/alerts/${props.id}" class="btn btn-sm btn-outline-secondary">View Details</a>
        </div>
    `;
}

// Create boundary popup content
function createBoundaryPopup(props, type) {
    const displayType = props.display_type || formatBoundaryLabel(props.type || type);
    return `
        <div class="popup-title">${props.name || 'Unnamed'}</div>
        <div class="popup-detail"><strong>Type:</strong> ${displayType}</div>
        <div class="popup-detail"><strong>ID:</strong> ${props.id}</div>
        ${props.description ? `<div class="popup-detail"><strong>Description:</strong> ${props.description}</div>` : ''}
        ${props.population ? `<div class="popup-detail"><strong>Population:</strong> ${props.population.toLocaleString()}</div>` : ''}
        ${props.area ? `<div class="popup-detail"><strong>Area:</strong> ${props.area} sq mi</div>` : ''}
    `;
}

// Utility functions
function getSeverityColor(severity) {
    const colors = {
        'Extreme': '#dc3545',
        'Severe': '#fd7e14',
        'Moderate': '#ffc107',
        'Minor': '#17a2b8'
    };
    return colors[severity] || '#6c757d';
}

function isAlertExpired(expiresDate) {
    if (!expiresDate) return false;
    return new Date(expiresDate) < new Date();
}

// Update UI functions
function updateMapStatus(status, type) {
    const badge = document.getElementById('map-status-badge');
    const statusElement = document.getElementById('map-status');

    if (badge) {
        badge.textContent = status;
        badge.className = `badge bg-${type} ms-2`;
    }

    if (statusElement) {
        statusElement.textContent = status;
    }
}

function updateAlertCount(count) {
    const element = document.getElementById('active-alert-count');
    if (element) {
        element.textContent = count;
    }
}

function updateBoundaryCount(count) {
    const element = document.getElementById('boundary-count');
    if (element) {
        element.textContent = count;
    }
}

function updateAlertSummary(alerts) {
    const summaryElement = document.getElementById('alert-summary');
    if (!summaryElement || !alerts || alerts.length === 0) return;

    const activeCounts = {};
    alerts.forEach(alert => {
        const event = alert.properties.event || 'Unknown';
        activeCounts[event] = (activeCounts[event] || 0) + 1;
    });

    const summaryHtml = Object.entries(activeCounts)
        .map(([event, count]) => `<div><strong>${event}:</strong> ${count}</div>`)
        .join('');

    summaryElement.innerHTML = `<h6>Active Alerts by Type:</h6>${summaryHtml}`;
    summaryElement.style.display = 'block';
}

async function updateSystemStatus() {
    try {
        const response = await fetch('/api/system_status');
        if (response.ok) {
            const data = await response.json();
            console.log('✅ System status updated:', data);
            // Update any additional system status here if needed
        }
    } catch (error) {
        console.warn('Could not fetch system status:', error);
    }

    // Update timestamp
    const element = document.getElementById('last-update');
    if (element) {
        element.textContent = new Date().toLocaleTimeString();
    }
}

// Event handlers
function setupEventListeners() {
    // Layer toggles
    document.getElementById('show-active').addEventListener('change', function() {
        if (this.checked && alertData.active) {
            displayAlerts(alertData.active);
        } else if (!this.checked) {
            alertLayer.clearLayers();
        }
    });

    document.getElementById('show-expired').addEventListener('change', function() {
        const dateFilters = document.getElementById('date-filters');
        if (this.checked) {
            dateFilters.style.display = 'block';
            // Set default dates (last 30 days)
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 30);

            document.getElementById('end-date').value = endDate.toISOString().split('T')[0];
            document.getElementById('start-date').value = startDate.toISOString().split('T')[0];
        } else {
            dateFilters.style.display = 'none';
            // Remove historical alerts from map
            if (alertData.active) {
                displayAlerts(alertData.active);
            }
        }
    });

}

// Action functions
async function refreshData() {
    const refreshBtn = document.getElementById('refresh-icon');
    if (refreshBtn) {
        refreshBtn.classList.add('fa-spin');
    }

    try {
        await Promise.all([
            loadAlerts(),
            updateSystemStatus()
        ]);
        showToast('Map data refreshed successfully', 'success');
    } catch (error) {
        showToast('Failed to refresh data', 'error');
    }

    setTimeout(() => {
        if (refreshBtn) {
            refreshBtn.classList.remove('fa-spin');
        }
    }, 2000);
}

function centerOnConfiguredLocation() {
    if (map) {
        map.setView(MAP_CENTER, MAP_ZOOM);
        showToast(`Map centered on ${LOCATION_LABEL}`, 'info');
    }
}

async function inspectBoundaries() {
    try {
        console.log('🔍 Inspecting boundaries...');
        const response = await fetch('/api/boundaries');

        if (!response.ok) {
            throw new Error(`API responded with status: ${response.status}`);
        }

        const data = await response.json();

        if (data.features && Array.isArray(data.features)) {
            // Group boundaries by type for inspection
            const boundariesByType = {};
            data.features.forEach(boundary => {
                const props = boundary.properties || {};
                const typeKey = resolveCanonicalBoundaryType(props.canonical_type || props.type || props.raw_type || 'unknown');
                const displayLabel = props.display_type || formatBoundaryLabel(typeKey);
                if (!boundariesByType[typeKey]) {
                    boundariesByType[typeKey] = {
                        label: displayLabel,
                        items: []
                    };
                }
                boundariesByType[typeKey].items.push({
                    id: props.id,
                    name: props.name,
                    description: props.description,
                    type: displayLabel
                });
            });

            // Sort types for better display
            const sortedTypes = Object.keys(boundariesByType).sort((a, b) => {
                const labelA = boundariesByType[a].label.toLowerCase();
                const labelB = boundariesByType[b].label.toLowerCase();
                return labelA.localeCompare(labelB);
            });

            // Create inspection report
            let report = `📊 COMPREHENSIVE BOUNDARY INSPECTION REPORT\n`;
            report += `=========================================================\n`;
            report += `Total Boundaries: ${data.features.length}\n`;
            report += `Boundary Types: ${sortedTypes.length}\n`;
            report += `Generated: ${new Date().toLocaleString()}\n\n`;

            // Summary by type
            report += `SUMMARY BY TYPE:\n`;
            report += `================\n`;
            sortedTypes.forEach(type => {
                const group = boundariesByType[type];
                const count = group.items.length;
                report += `${group.label.toUpperCase()}: ${count}\n`;
            });
            report += `\n`;

            // Detailed listings
            sortedTypes.forEach(type => {
                const group = boundariesByType[type];
                const boundaries = group.items;
                report += `${group.label.toUpperCase()} DETAILS (${boundaries.length}):\n`;
                report += `${'='.repeat(group.label.length + 15)}\n`;
                boundaries.forEach((boundary, index) => {
                    report += `  ${index + 1}. ${boundary.name} (ID: ${boundary.id})\n`;
                    if (boundary.description) {
                        report += `     Description: ${boundary.description}\n`;
                    }
                });
                report += `\n`;
            });

            // Show in console
            console.log(report);

            // Create enhanced inspection window
            const inspectionWindow = window.open('', '_blank', 'width=800,height=600,scrollbars=yes,resizable=yes');
            inspectionWindow.document.write(`
                <html>
                <head>
                    <title>Comprehensive Boundary Inspection Report</title>
                    <style>
                        body {
                            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                            padding: 20px;
                            background: #f5f5f5;
                            margin: 0;
                        }
                        .report {
                            background: white;
                            padding: 30px;
                            border-radius: 8px;
                            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                            max-width: 1000px;
                            margin: 0 auto;
                        }
                        h1 {
                            color: #007bff;
                            border-bottom: 3px solid #007bff;
                            padding-bottom: 10px;
                        }
                        .summary {
                            background: #e9ecef;
                            padding: 20px;
                            border-radius: 8px;
                            margin: 20px 0;
                        }
                        .summary h2 {
                            color: #28a745;
                            margin-top: 0;
                        }
                        .type-section {
                            margin-bottom: 30px;
                            border: 1px solid #dee2e6;
                            border-radius: 8px;
                            padding: 20px;
                        }
                        .type-header {
                            font-weight: bold;
                            color: #dc3545;
                            margin-bottom: 15px;
                            font-size: 1.2em;
                            border-bottom: 2px solid #dc3545;
                            padding-bottom: 5px;
                        }
                        .boundary-item {
                            margin-left: 20px;
                            margin-bottom: 10px;
                            padding: 8px;
                            background: #f8f9fa;
                            border-radius: 4px;
                        }
                        .boundary-name {
                            font-weight: bold;
                            color: #007bff;
                        }
                        .boundary-id {
                            color: #6c757d;
                            font-size: 0.9em;
                        }
                        .description {
                            color: #495057;
                            font-style: italic;
                            margin-top: 5px;
                            padding: 5px;
                            background: white;
                            border-radius: 4px;
                        }
                        .stats-grid {
                            display: grid;
                            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                            gap: 15px;
                            margin: 20px 0;
                        }
                        .stat-box {
                            background: #007bff;
                            color: white;
                            padding: 15px;
                            border-radius: 8px;
                            text-align: center;
                        }
                        .stat-number {
                            font-size: 2em;
                            font-weight: bold;
                            display: block;
                        }
                        .stat-label {
                            font-size: 0.9em;
                            opacity: 0.9;
                        }
                        @media print {
                            body { background: white; }
                            .report { box-shadow: none; }
                        }
                    </style>
                </head>
                <body>
                    <div class="report">
                        <h1>🗺️ Comprehensive Boundary Inspection Report</h1>

                        <div class="summary">
                            <h2>📊 System Overview</h2>
                            <div class="stats-grid">
                                <div class="stat-box">
                                    <span class="stat-number">${data.features.length}</span>
                                    <span class="stat-label">Total Boundaries</span>
                                </div>
                                <div class="stat-box">
                                    <span class="stat-number">${sortedTypes.length}</span>
                                    <span class="stat-label">Boundary Types</span>
                                </div>
                                <div class="stat-box">
                                    <span class="stat-number">${new Date().toLocaleDateString()}</span>
                                    <span class="stat-label">Report Date</span>
                                </div>
                            </div>
                        </div>

                        <div class="summary">
                            <h2>📈 Type Distribution</h2>
                            ${sortedTypes.map(type => {
                                const count = boundariesByType[type].length;
                                const percentage = ((count / data.features.length) * 100).toFixed(1);
                                return `<div><strong>${type.toUpperCase()}:</strong> ${count} boundaries (${percentage}%)</div>`;
                            }).join('')}
                        </div>

                        ${sortedTypes.map(type => {
                            const boundaries = boundariesByType[type];
                            const typeColors = {
                                'county': '#6c757d', 'township': '#28a745', 'village': '#17a2b8',
                                'fire': '#dc3545', 'ems': '#007bff', 'school': '#ffc107',
                                'electric': '#fd7e14', 'telephone': '#6f42c1'
                            };
                            const color = typeColors[type.toLowerCase()] || '#6c757d';

                            return `
                                <div class="type-section">
                                    <div class="type-header" style="color: ${color}; border-bottom-color: ${color};">
                                        ${type.toUpperCase()} BOUNDARIES (${boundaries.length})
                                    </div>
                                    ${boundaries.map((boundary, index) => `
                                        <div class="boundary-item">
                                            <div class="boundary-name">${boundary.name}</div>
                                            <div class="boundary-id">ID: ${boundary.id} | Type: ${boundary.type}</div>
                                            ${boundary.description ? `<div class="description">${boundary.description}</div>` : ''}
                                        </div>
                                    `).join('')}
                                </div>
                            `;
                        }).join('')}

                        <div class="summary">
                            <p><strong>📍 System Location:</strong> ${LOCATION_LABEL} Emergency Management</p>
                            <p><strong>🔧 Generated by:</strong> KR8MER CAP Emergency Alert System</p>
                            <p><small>This comprehensive report shows all boundary data available in the emergency management system database.</small></p>
                        </div>
                    </div>
                </body>
                </html>
            `);

            showToast(`Comprehensive boundary inspection complete: ${data.features.length} boundaries across ${sortedTypes.length} types`, 'success');

        } else {
            showToast('No boundaries found in system', 'warning');
        }
    } catch (error) {
        console.error('❌ Error inspecting boundaries:', error);
        showToast('Failed to inspect boundaries: ' + error.message, 'error');
    }
}

// Error handling
function showMapError(message) {
    const mapContainer = document.getElementById('map');
    if (mapContainer) {
        mapContainer.innerHTML = `
            <div class="map-error">
                <i class="fas fa-exclamation-triangle" style="font-size: 3em; margin-bottom: 15px;"></i>
                <h4>Map Loading Error</h4>
                <p>${message}</p>
                <button class="btn btn-primary" onclick="window.location.reload()">
                    <i class="fas fa-redo"></i> Reload Page
                </button>
            </div>
        `;
    }
}

// Initialize everything when page loads
document.addEventListener('DOMContentLoaded', function() {
    console.log('📄 Interactive map page loaded');

    try {
        initMap();

        // Auto-refresh every 5 minutes
        setInterval(() => {
            loadAlerts();
            updateSystemStatus();
        }, 300000);

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.key === 'r' || e.key === 'R') {
                if (!e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    refreshData();
                }
            }
        });

    } catch (error) {
        console.error('❌ Error initializing page:', error);
        showMapError('Failed to initialize map interface: ' + error.message);
    }
});

console.log('📜 Interactive map script loaded');

// Make diagnostic functions available globally for debugging
window.mapDebug = {
    testAPIs: async function() {
        console.log('🔍 Testing all API endpoints...');

        const endpoints = [
            '/api/alerts',
            '/api/boundaries',
            '/api/system_status'
        ];

        for (const endpoint of endpoints) {
            try {
                const response = await fetch(endpoint);
                const data = await response.json();
                console.log(`✅ ${endpoint}: ${response.status}`, data);
            } catch (error) {
                console.error(`❌ ${endpoint}: ${error.message}`);
            }
        }
    },

    refreshAll: function() {
        console.log('🔄 Refreshing all map data...');
        refreshData();
    },

    inspectMap: function() {
        console.log('🗺️ Map inspection:');
        console.log('Map object:', map);
        console.log('Alert layer:', alertLayer);
        console.log('Boundary layers:', boundaryLayers);
        console.log('Alert data:', alertData);
    },

    analyzeBoundaries: async function() {
        console.log('📊 Analyzing boundary data...');
        try {
            const response = await fetch('/api/boundaries');
            const data = await response.json();

            if (data.features) {
                const analysis = {};
                data.features.forEach(boundary => {
                    const props = boundary.properties || {};
                    const typeKey = resolveCanonicalBoundaryType(props.canonical_type || props.type || props.raw_type || 'unknown');
                    if (!analysis[typeKey]) {
                        analysis[typeKey] = { count: 0, examples: [], label: formatBoundaryLabel(typeKey) };
                    }
                    analysis[typeKey].count++;
                    if (analysis[typeKey].examples.length < 3) {
                        analysis[typeKey].examples.push({
                            name: props.name,
                            id: props.id
                        });
                    }
                });

                console.log('📋 Boundary Analysis:');
                const tableData = Object.entries(analysis).map(([key, info]) => ({
                    type: info.label || formatBoundaryLabel(key),
                    count: info.count,
                    examples: info.examples.map(example => example.name).join(', ')
                }));
                console.table(tableData);
                return analysis;
            }
        } catch (error) {
            console.error('❌ Analysis failed:', error);
        }
    }
};

console.log('💡 Debug functions available:');
console.log('  • window.mapDebug.testAPIs() - Test all API endpoints');
console.log('  • window.mapDebug.refreshAll() - Refresh all map data');
console.log('  • window.mapDebug.inspectMap() - Inspect map objects');
console.log('  • window.mapDebug.analyzeBoundaries() - Analyze boundary types');
</script>
{% endblock %}