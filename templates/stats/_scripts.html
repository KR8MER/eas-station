<!-- Load Highcharts and modules -->
<script>
(function setupHighchartsLoader() {
    const REQUIRED_SCRIPTS = [
        'https://code.highcharts.com/11.4.1/stock/highstock.js',
        'https://code.highcharts.com/11.4.1/highcharts-more.js',
        'https://code.highcharts.com/11.4.1/modules/heatmap.js',
        'https://code.highcharts.com/11.4.1/modules/solid-gauge.js',
        'https://code.highcharts.com/11.4.1/modules/xrange.js',
        'https://code.highcharts.com/11.4.1/modules/drilldown.js',
        'https://code.highcharts.com/11.4.1/modules/exporting.js',
        'https://code.highcharts.com/11.4.1/modules/export-data.js',
        'https://code.highcharts.com/11.4.1/modules/accessibility.js'
    ];

    if (window.__highchartsLoadPromise) {
        return;
    }

    function loadScript(src) {
        return new Promise((resolve, reject) => {
            const existing = Array.from(document.getElementsByTagName('script')).find((script) => script.src === src);
            if (existing) {
                const managedByLoader = existing.dataset.highchartsLoader === 'stats-dashboard';
                const alreadyLoaded = existing.dataset.highchartsLoaded === 'true'
                    || !managedByLoader
                    || existing.readyState === 'complete'
                    || existing.readyState === 'loaded';
                if (alreadyLoaded) {
                    resolve();
                    return;
                }
                existing.addEventListener('load', () => resolve(), { once: true });
                existing.addEventListener('error', () => reject(new Error(`Failed to load Highcharts resource: ${src}`)), { once: true });
                return;
            }

            const script = document.createElement('script');
            script.src = src;
            script.dataset.highchartsLoader = 'stats-dashboard';
            script.addEventListener('load', () => {
                script.dataset.highchartsLoaded = 'true';
                resolve();
            }, { once: true });
            script.addEventListener('error', () => {
                reject(new Error(`Failed to load Highcharts resource: ${src}`));
            }, { once: true });
            document.head.appendChild(script);
        });
    }

    if (window.Highcharts) {
        window.__highchartsLoadPromise = Promise.resolve(window.Highcharts);
        Promise.resolve().then(() => document.dispatchEvent(new Event('highcharts:loaded')));
        return;
    }

    const loadPromise = REQUIRED_SCRIPTS.reduce((chain, src) => chain.then(() => loadScript(src)), Promise.resolve())
        .then(() => {
            if (!window.Highcharts) {
                throw new Error('Highcharts did not initialize as expected.');
            }
            return window.Highcharts;
        });

    window.__highchartsLoadPromise = loadPromise;

    loadPromise
        .then(() => {
            document.dispatchEvent(new Event('highcharts:loaded'));
        })
        .catch((error) => {
            window.__highchartsLoadError = error;
            document.dispatchEvent(new CustomEvent('highcharts:failed', { detail: error }));
        });
})();
</script>

<script>
console.log('ðŸš€ Statistics dashboard initializing...');

const statsData = {
    alertByEvent: {{ alert_by_event | tojson | safe }} || [],
    alertBySeverity: {{ alert_by_severity | tojson | safe }} || [],
    alertByStatus: {{ alert_by_status | tojson | safe }} || [],
    alertByYear: {{ alert_by_year | tojson | safe }} || [],
    mostAffectedBoundaries: {{ most_affected_boundaries | tojson | safe }} || [],
    avgDurations: {{ avg_durations | tojson | safe }} || [],
    recentByDay: {{ recent_by_day | tojson | safe }} || [],
    boundaryStats: {{ boundary_stats | tojson | safe }} || [],
    polling: {{ polling | tojson | safe }} || {},
    alertEvents: {{ alert_events | tojson | safe }} || [],
    filterOptions: {{ filter_options | tojson | safe }} || {"severities": [], "statuses": [], "events": []},
    dailyAlerts: {{ daily_alerts | tojson | safe }} || [],
    dowHourMatrix: {{ dow_hour_matrix | tojson | safe }} || Array.from({ length: 7 }, () => Array(24).fill(0)),
    lifecycleTimeline: {{ lifecycle_timeline | tojson | safe }} || []
};
console.log('âœ… Data loaded:', statsData);

const baseAlerts = (statsData.alertEvents || []).map(alert => ({
    ...alert,
    sentDate: alert.sent ? new Date(alert.sent) : null,
    expiresDate: alert.expires ? new Date(alert.expires) : null
})).filter(alert => alert.sentDate && !Number.isNaN(alert.sentDate.getTime()));

const ACTIVE_STATUS_CANDIDATES = ['actual', 'active', 'alert', 'in effect'];
const EXPIRED_STATUS_CANDIDATES = ['expired', 'past', 'cancelled', 'canceled', 'cancel', 'ended', 'test'];

const severityColors = {
    'Extreme': '#dc3545',
    'Severe': '#fd7e14',
    'Moderate': '#ffc107',
    'Minor': '#17a2b8',
    'Unknown': '#6c757d'
};

const state = {
    charts: {},
    filters: {
        preset: 'last30',
        startDate: null,
        endDate: null,
        severities: new Set(),
        statuses: new Set(),
        events: new Set()
    },
    filteredAlerts: [],
    aggregates: null,
    staticChartsInitialized: false
};

let highchartsDefaultsConfigured = false;

function configureHighchartsDefaults() {
    if (highchartsDefaultsConfigured) {
        return;
    }
    if (!window.Highcharts) {
        throw new Error('Highcharts is not available.');
    }
    Highcharts.setOptions({
        colors: ['#007bff', '#28a745', '#ffc107', '#dc3545', '#17a2b8', '#6f42c1', '#fd7e14', '#20c997', '#6c757d'],
        chart: {
            backgroundColor: 'transparent',
            style: { fontFamily: 'Segoe UI, sans-serif' }
        },
        credits: { enabled: false },
        title: { style: { color: '#212529', fontSize: '16px' } }
    });
    highchartsDefaultsConfigured = true;
}

function populateFilterSelect(id, options) {
    const select = document.getElementById(id);
    if (!select) return;
    select.innerHTML = '';
    options.forEach(option => {
        const opt = document.createElement('option');
        opt.value = option;
        opt.textContent = option;
        select.appendChild(opt);
    });
}

function setPresetDates(preset) {
    const end = new Date();
    end.setHours(23, 59, 59, 999);
    const start = new Date(end);
    switch (preset) {
        case 'last7':
            start.setDate(end.getDate() - 6);
            break;
        case 'last30':
            start.setDate(end.getDate() - 29);
            break;
        case 'last90':
            start.setDate(end.getDate() - 89);
            break;
        case 'last180':
            start.setDate(end.getDate() - 179);
            break;
        case 'last365':
            start.setDate(end.getDate() - 364);
            break;
        default:
            return;
    }
    start.setHours(0, 0, 0, 0);
    state.filters.preset = preset;
    state.filters.startDate = start;
    state.filters.endDate = end;
    updateDateInputs();
}

function updateDateInputs() {
    const startInput = document.getElementById('startDateInput');
    const endInput = document.getElementById('endDateInput');
    if (startInput) {
        startInput.value = state.filters.startDate ? state.filters.startDate.toISOString().slice(0, 10) : '';
    }
    if (endInput) {
        const endDate = state.filters.endDate ? new Date(state.filters.endDate) : null;
        if (endDate) {
            endDate.setHours(0, 0, 0, 0);
        }
        endInput.value = endDate ? endDate.toISOString().slice(0, 10) : '';
    }
}

function handlePresetChange(event) {
    const preset = event.target.value;
    if (preset !== 'custom') {
        setPresetDates(preset);
        applyFiltersFromInputs();
    } else {
        state.filters.preset = 'custom';
    }
}

function getSelectedValues(selectElement) {
    if (!selectElement) return [];
    return Array.from(selectElement.selectedOptions).map(option => option.value);
}

function applyFiltersFromInputs() {
    const datePreset = document.getElementById('dateRangePreset');
    const presetValue = datePreset ? datePreset.value : state.filters.preset;
    if (presetValue === 'custom') {
        state.filters.preset = 'custom';
        const startInput = document.getElementById('startDateInput');
        const endInput = document.getElementById('endDateInput');
        state.filters.startDate = startInput && startInput.value ? new Date(startInput.value + 'T00:00:00') : null;
        state.filters.endDate = endInput && endInput.value ? new Date(endInput.value + 'T23:59:59') : null;
    } else {
        setPresetDates(presetValue);
    }

    const severityFilter = document.getElementById('severityFilter');
    const statusFilter = document.getElementById('statusFilter');
    const eventFilter = document.getElementById('eventFilter');

    state.filters.severities = new Set(getSelectedValues(severityFilter));
    state.filters.statuses = new Set(getSelectedValues(statusFilter));
    state.filters.events = new Set(getSelectedValues(eventFilter));

    updateDashboard();
}

function resetFilters() {
    state.filters = {
        preset: 'last30',
        startDate: null,
        endDate: null,
        severities: new Set(),
        statuses: new Set(),
        events: new Set()
    };
    const datePreset = document.getElementById('dateRangePreset');
    if (datePreset) {
        datePreset.value = 'last30';
    }
    ['severityFilter', 'statusFilter', 'eventFilter'].forEach(id => {
        const select = document.getElementById(id);
        if (select) {
            Array.from(select.options).forEach(option => { option.selected = false; });
        }
    });
    setPresetDates('last30');
    updateDashboard();
}

function exportFilteredData() {
    if (!state.filteredAlerts.length) {
        alert('No filtered alerts to export.');
        return;
    }
    const header = ['identifier', 'sent', 'expires', 'severity', 'status', 'event'];
    const rows = state.filteredAlerts.map(alert => [
        `"${alert.id || ''}"`,
        alert.sentDate ? alert.sentDate.toISOString() : '',
        alert.expiresDate ? alert.expiresDate.toISOString() : '',
        `"${alert.severity}"`,
        `"${alert.status}"`,
        `"${alert.event}"`
    ].join(','));
    const csvContent = [header.join(','), ...rows].join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'filtered_alerts.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

function updateFilterSummary(filteredAlerts) {
    const summary = document.getElementById('filterSummary');
    if (!summary) return;
    const formatter = new Intl.NumberFormat();
    const pieces = [];
    pieces.push(`<strong>${formatter.format(filteredAlerts.length)}</strong> alerts match the current filters.`);
    if (state.filters.startDate || state.filters.endDate) {
        const startText = state.filters.startDate ? state.filters.startDate.toLocaleDateString() : 'beginning';
        const endText = state.filters.endDate ? state.filters.endDate.toLocaleDateString() : 'now';
        pieces.push(`<span class="filter-pill"><i class="fas fa-calendar"></i> ${startText} â†’ ${endText}</span>`);
    }
    if (state.filters.severities.size) {
        pieces.push(`<span class="filter-pill"><i class="fas fa-exclamation-triangle"></i> ${Array.from(state.filters.severities).join(', ')}</span>`);
    }
    if (state.filters.statuses.size) {
        pieces.push(`<span class="filter-pill"><i class="fas fa-toggle-on"></i> ${Array.from(state.filters.statuses).join(', ')}</span>`);
    }
    if (state.filters.events.size) {
        pieces.push(`<span class="filter-pill"><i class="fas fa-bell"></i> ${Array.from(state.filters.events).join(', ')}</span>`);
    }
    summary.innerHTML = pieces.join(' ');
}

function updateQuickStats(aggregates) {
    const formatter = new Intl.NumberFormat();
    const totalEl = document.getElementById('filteredTotalAlerts');
    if (totalEl) {
        totalEl.textContent = formatter.format(aggregates.totalAlerts);
    }
    const avgEl = document.getElementById('filteredAvgPerDay');
    if (avgEl) {
        avgEl.textContent = aggregates.avgPerDay ? aggregates.avgPerDay.toFixed(1) : '0';
    }
    const severityEl = document.getElementById('filteredTopSeverity');
    if (severityEl) {
        severityEl.textContent = aggregates.topSeverity || 'â€”';
    }
    const eventEl = document.getElementById('filteredTopEvent');
    if (eventEl) {
        eventEl.textContent = aggregates.topEvent || 'â€”';
    }
}

function sumStatusCounts(aggregates, candidates) {
    if (!aggregates.statusTotalsNormalized) {
        return 0;
    }
    return candidates.reduce((acc, candidate) => acc + (aggregates.statusTotalsNormalized.get(candidate.toLowerCase()) || 0), 0);
}

function updateKpiCards(aggregates) {
    const formatter = new Intl.NumberFormat();
    const totalDelta = document.getElementById('totalAlertsDelta');
    if (totalDelta) {
        totalDelta.textContent = `Filtered: ${formatter.format(aggregates.totalAlerts)}`;
    }
    const activeDelta = document.getElementById('activeAlertsDelta');
    if (activeDelta) {
        const activeCount = sumStatusCounts(aggregates, ACTIVE_STATUS_CANDIDATES);
        activeDelta.textContent = `Filtered: ${formatter.format(activeCount)}`;
        activeDelta.classList.toggle('positive', activeCount > 0);
    }
    const expiredDelta = document.getElementById('expiredAlertsDelta');
    if (expiredDelta) {
        const expiredCount = sumStatusCounts(aggregates, EXPIRED_STATUS_CANDIDATES);
        expiredDelta.textContent = `Filtered: ${formatter.format(expiredCount)}`;
        expiredDelta.classList.toggle('negative', expiredCount > 0);
    }
    const boundaryDelta = document.getElementById('boundaryDelta');
    if (boundaryDelta) {
        boundaryDelta.textContent = 'Static: based on configured geography';
    }
    const uptimeDelta = document.getElementById('uptimeDelta');
    if (uptimeDelta) {
        uptimeDelta.textContent = 'Approximate launch date baseline';
    }
    const reliabilityDelta = document.getElementById('reliabilityDelta');
    if (reliabilityDelta && statsData.polling) {
        reliabilityDelta.textContent = `Source: ${statsData.polling.data_source || 'poll_history'}`;
    }
}

function buildStatusSparklineSeries(aggregates, candidates) {
    if (!aggregates.dailyStatusCounts) {
        return [];
    }
    const combined = new Map();
    candidates.forEach(candidate => {
        const series = aggregates.dailyStatusCounts.get(candidate.toLowerCase());
        if (!series) return;
        series.forEach((count, day) => {
            combined.set(day, (combined.get(day) || 0) + count);
        });
    });
    return Array.from(combined.entries())
        .sort((a, b) => new Date(a[0]) - new Date(b[0]))
        .slice(-14)
        .map(([date, count]) => [new Date(date).getTime(), count]);
}

function createSparkline(containerId, series, color) {
    const container = document.getElementById(containerId);
    if (!container || !series.length) {
        return;
    }
    if (state.charts[containerId]) {
        state.charts[containerId].destroy();
    }
    state.charts[containerId] = Highcharts.chart(containerId, {
        chart: {
            type: 'areaspline',
            backgroundColor: 'transparent',
            height: 60,
            margin: [0, 0, 0, 0]
        },
        title: { text: null },
        credits: { enabled: false },
        legend: { enabled: false },
        xAxis: {
            type: 'datetime',
            labels: { enabled: false },
            lineWidth: 0,
            tickLength: 0
        },
        yAxis: {
            labels: { enabled: false },
            title: { text: null },
            gridLineWidth: 0
        },
        tooltip: {
            valueDecimals: 0,
            valueSuffix: ' alerts',
            xDateFormat: '%b %e'
        },
        plotOptions: {
            areaspline: {
                marker: { enabled: false },
                lineWidth: 1.5,
                fillOpacity: 0.3
            }
        },
        series: [{
            data: series,
            color
        }]
    });
}

function renderSparklines(aggregates) {
    const totalSeries = aggregates.dailySeries.slice(-14).map(item => [new Date(item.date).getTime(), item.count]);
    if (totalSeries.length) {
        createSparkline('sparkline-total', totalSeries, '#007bff');
    }
    const activeSeries = buildStatusSparklineSeries(aggregates, ACTIVE_STATUS_CANDIDATES);
    if (activeSeries.length) {
        createSparkline('sparkline-active', activeSeries, '#28a745');
    }
    const expiredSeries = buildStatusSparklineSeries(aggregates, EXPIRED_STATUS_CANDIDATES);
    if (expiredSeries.length) {
        createSparkline('sparkline-expired', expiredSeries, '#dc3545');
    }
}

function getFilteredAlerts() {
    const start = state.filters.startDate ? new Date(state.filters.startDate) : null;
    const end = state.filters.endDate ? new Date(state.filters.endDate) : null;
    if (start) {
        start.setHours(0, 0, 0, 0);
    }
    if (end) {
        end.setHours(23, 59, 59, 999);
    }
    return baseAlerts.filter(alert => {
        if (start && alert.sentDate < start) return false;
        if (end && alert.sentDate > end) return false;
        if (state.filters.severities.size && !state.filters.severities.has(alert.severity)) return false;
        if (state.filters.statuses.size && !state.filters.statuses.has(alert.status)) return false;
        if (state.filters.events.size && !state.filters.events.has(alert.event)) return false;
        return true;
    });
}
function computeMovingAverage(dailySeries, window) {
    if (!dailySeries.length) return [];
    const values = dailySeries.map(item => item.count);
    return dailySeries.map((item, idx) => {
        const start = Math.max(0, idx - window + 1);
        const slice = values.slice(start, idx + 1);
        const avg = slice.reduce((acc, value) => acc + value, 0) / slice.length;
        return { date: item.date, value: Number(avg.toFixed(2)) };
    });
}

function startOfWeek(date) {
    const result = new Date(date);
    result.setHours(0, 0, 0, 0);
    const day = result.getDay();
    const diff = (day + 6) % 7;
    result.setDate(result.getDate() - diff);
    return result;
}

function computeTimelineComparison(dailySeries, filters) {
    if (!dailySeries.length) {
        return null;
    }
    const endDate = filters.endDate ? new Date(filters.endDate) : new Date(dailySeries[dailySeries.length - 1].date);
    endDate.setHours(0, 0, 0, 0);
    const currentWeekStart = startOfWeek(endDate);
    const previousWeekStart = new Date(currentWeekStart);
    previousWeekStart.setDate(previousWeekStart.getDate() - 7);
    const lastYearStart = new Date(currentWeekStart);
    lastYearStart.setFullYear(lastYearStart.getFullYear() - 1);

    const dayMap = new Map(dailySeries.map(item => [item.date, item.count]));

    function buildSeries(start) {
        const series = [];
        for (let i = 0; i < 7; i += 1) {
            const day = new Date(start);
            day.setDate(start.getDate() + i);
            const key = day.toISOString().slice(0, 10);
            series.push({ date: key, count: dayMap.get(key) || 0 });
        }
        return series;
    }

    const movingAverages = {
        sevenDay: computeMovingAverage(dailySeries, 7),
        thirtyDay: computeMovingAverage(dailySeries, 30),
        ninetyDay: computeMovingAverage(dailySeries, 90)
    };

    const peakDay = dailySeries.reduce((acc, item) => {
        if (!acc || item.count > acc.count) return item;
        return acc;
    }, null);

    return {
        currentWeek: buildSeries(currentWeekStart),
        previousWeek: buildSeries(previousWeekStart),
        lastYearWeek: buildSeries(lastYearStart),
        movingAverages,
        annotations: peakDay ? [{ date: peakDay.date, text: `Peak: ${peakDay.count} alerts` }] : []
    };
}

function computeSeasonalAverage(dailySeries) {
    const buckets = Array.from({ length: 7 }, () => []);
    dailySeries.forEach(item => {
        const dow = new Date(item.date).getDay();
        buckets[dow].push(item.count);
    });
    return buckets.map((values, index) => ({
        dow: index,
        average: values.length ? Number((values.reduce((a, b) => a + b, 0) / values.length).toFixed(2)) : 0
    }));
}

function computeForecast(dailySeries) {
    if (dailySeries.length < 7) {
        return null;
    }
    const counts = dailySeries.map(item => item.count);
    const x = dailySeries.map((_, idx) => idx);
    const meanX = x.reduce((acc, val) => acc + val, 0) / x.length;
    const meanY = counts.reduce((acc, val) => acc + val, 0) / counts.length;
    const numerator = x.reduce((acc, val, idx) => acc + (val - meanX) * (counts[idx] - meanY), 0);
    const denominator = x.reduce((acc, val) => acc + Math.pow(val - meanX, 2), 0) || 1;
    const slope = numerator / denominator;
    const intercept = meanY - slope * meanX;
    const residuals = counts.map((value, idx) => value - (slope * x[idx] + intercept));
    const variance = residuals.reduce((acc, val) => acc + Math.pow(val, 2), 0) / (residuals.length || 1);
    const stdDev = Math.sqrt(variance);
    const interval = 1.96 * stdDev;

    const lastDate = new Date(dailySeries[dailySeries.length - 1].date);
    const projection = [];
    let total = 0;

    for (let i = 1; i <= 7; i += 1) {
        const forecastDate = new Date(lastDate);
        forecastDate.setDate(forecastDate.getDate() + i);
        const xi = x.length + i - 1;
        const value = slope * xi + intercept;
        const normalized = Math.max(value, 0);
        total += normalized;
        projection.push({
            date: forecastDate.toISOString().slice(0, 10),
            value: Number(normalized.toFixed(2)),
            lower: Number(Math.max(normalized - interval, 0).toFixed(2)),
            upper: Number((normalized + interval).toFixed(2))
        });
    }

    return {
        projection,
        interval,
        expectedNext7: Number(total.toFixed(1)),
        seasonal: computeSeasonalAverage(dailySeries)
    };
}

function formatMonthKey(monthKey) {
    const [year, month] = monthKey.split('-').map(Number);
    const date = new Date(Date.UTC(year, month - 1, 1));
    return date.toLocaleDateString(undefined, { month: 'short', year: 'numeric' });
}

function computeMasterDetail(alerts) {
    const events = new Map();
    alerts.forEach(alert => {
        const eventName = alert.event || 'Unknown';
        const sent = alert.sentDate;
        if (!sent) return;
        const monthKey = `${sent.getFullYear()}-${String(sent.getMonth() + 1).padStart(2, '0')}`;
        if (!events.has(eventName)) {
            events.set(eventName, { total: 0, months: new Map() });
        }
        const eventEntry = events.get(eventName);
        eventEntry.total += 1;
        if (!eventEntry.months.has(monthKey)) {
            eventEntry.months.set(monthKey, { count: 0, days: new Map() });
        }
        const monthEntry = eventEntry.months.get(monthKey);
        monthEntry.count += 1;
        const dayKey = sent.toISOString().slice(0, 10);
        monthEntry.days.set(dayKey, (monthEntry.days.get(dayKey) || 0) + 1);
    });

    const baseSeries = [];
    const drilldownSeries = [];
    const sortedEvents = Array.from(events.entries()).sort((a, b) => b[1].total - a[1].total).slice(0, 6);

    sortedEvents.forEach(([eventName, data]) => {
        baseSeries.push({ name: eventName, y: data.total, drilldown: eventName });
        const months = Array.from(data.months.entries())
            .sort((a, b) => new Date(`${a[0]}-01`) - new Date(`${b[0]}-01`))
            .slice(-12);

        months.forEach(([monthKey, monthData]) => {
            const drillId = `${eventName}|${monthKey}`;
            drilldownSeries.push({
                id: drillId,
                name: `${eventName} in ${formatMonthKey(monthKey)}`,
                type: 'column',
                data: Array.from(monthData.days.entries())
                    .sort((a, b) => new Date(a[0]) - new Date(b[0]))
                    .map(([day, count]) => [day, count])
            });
        });

        drilldownSeries.push({
            id: eventName,
            name: `${eventName} by month`,
            type: 'column',
            data: months.map(([monthKey, monthData]) => [formatMonthKey(monthKey), monthData.count])
        });
    });

    return { baseSeries, drilldownSeries };
}
function aggregateAlerts(alerts, filters) {
    const eventCounts = new Map();
    const severityCounts = new Map();
    const statusCounts = new Map();
    const statusTotalsNormalized = new Map();
    const statusDisplayNames = new Map();
    const hourlyTotals = Array(24).fill(0);
    const monthlyTotals = Array(12).fill(0);
    const yearlyCounts = new Map();
    const hourlyMatrix = Array.from({ length: 7 }, () => Array(24).fill(0));
    const dailyCounts = new Map();
    const dailyStatusCounts = new Map();

    alerts.forEach(alert => {
        const sent = alert.sentDate;
        if (!sent) return;
        const dayKey = sent.toISOString().slice(0, 10);
        const hour = sent.getHours();
        const dow = sent.getDay();
        const month = sent.getMonth();
        const year = sent.getFullYear();

        const severity = alert.severity || 'Unknown';
        const status = alert.status || 'Unknown';
        const eventName = alert.event || 'Unknown';
        const statusKey = status.toLowerCase();

        eventCounts.set(eventName, (eventCounts.get(eventName) || 0) + 1);
        severityCounts.set(severity, (severityCounts.get(severity) || 0) + 1);
        statusCounts.set(status, (statusCounts.get(status) || 0) + 1);
        statusTotalsNormalized.set(statusKey, (statusTotalsNormalized.get(statusKey) || 0) + 1);
        if (!statusDisplayNames.has(statusKey)) {
            statusDisplayNames.set(statusKey, status);
        }

        hourlyTotals[hour] += 1;
        hourlyMatrix[dow][hour] += 1;
        monthlyTotals[month] += 1;
        yearlyCounts.set(year, (yearlyCounts.get(year) || 0) + 1);
        dailyCounts.set(dayKey, (dailyCounts.get(dayKey) || 0) + 1);

        if (!dailyStatusCounts.has(statusKey)) {
            dailyStatusCounts.set(statusKey, new Map());
        }
        const statusDaily = dailyStatusCounts.get(statusKey);
        statusDaily.set(dayKey, (statusDaily.get(dayKey) || 0) + 1);
    });

    const dailySeries = Array.from(dailyCounts.entries())
        .sort((a, b) => new Date(a[0]) - new Date(b[0]))
        .map(([date, count]) => ({ date, count }));
    const recentByDay = dailySeries.slice(-30);
    const dowTotals = hourlyMatrix.map(row => row.reduce((acc, value) => acc + value, 0));
    const timelineComparison = computeTimelineComparison(dailySeries, filters);
    const forecast = computeForecast(dailySeries);
    const masterDetail = computeMasterDetail(alerts);
    const yearlyTotals = Array.from(yearlyCounts.entries())
        .sort((a, b) => a[0] - b[0])
        .map(([year, count]) => ({ year, count }));

    const alertByEvent = Array.from(eventCounts.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([event, count]) => ({ event, count }));

    const alertBySeverity = Array.from(severityCounts.entries())
        .sort((a, b) => b[1] - a[1])
        .map(([severity, count]) => ({ severity, count }));

    const alertByStatus = Array.from(statusCounts.entries())
        .sort((a, b) => b[1] - a[1])
        .map(([status, count]) => ({ status, count }));

    const totalAlerts = alerts.length;
    const avgPerDay = dailySeries.length ? (dailySeries.reduce((acc, item) => acc + item.count, 0) / dailySeries.length) : 0;
    const topSeverity = alertBySeverity.length ? alertBySeverity[0].severity : 'â€”';
    const topEvent = alertByEvent.length ? alertByEvent[0].event : 'â€”';
    const peakDay = timelineComparison && timelineComparison.annotations.length ? timelineComparison.annotations[0] : null;

    return {
        totalAlerts,
        alertByEvent,
        alertBySeverity,
        alertByStatus,
        hourlyTotals,
        hourlyMatrix,
        dowTotals,
        monthlyTotals,
        yearlyTotals,
        dailySeries,
        recentByDay,
        timelineComparison,
        forecast,
        masterDetail,
        avgPerDay,
        topSeverity,
        topEvent,
        statusTotalsNormalized,
        statusDisplayNames,
        dailyStatusCounts,
        peakDay
    };
}

function createOrUpdateChart(containerId, chartFactory) {
    const container = document.getElementById(containerId);
    if (!container) {
        return;
    }
    if (state.charts[containerId]) {
        state.charts[containerId].destroy();
    }
    container.innerHTML = '';
    const chart = chartFactory(container);
    if (chart) {
        state.charts[containerId] = chart;
    }
}

function showError(containerId, message) {
    const container = document.getElementById(containerId);
    if (!container) return;
    if (state.charts[containerId]) {
        state.charts[containerId].destroy();
        delete state.charts[containerId];
    }
    container.innerHTML = `<div class="simple-chart text-danger"><i class="fas fa-exclamation-triangle"></i> ${message}</div>`;
}

function showNoData(containerId, message) {
    const container = document.getElementById(containerId);
    if (!container) return;
    if (state.charts[containerId]) {
        state.charts[containerId].destroy();
        delete state.charts[containerId];
    }
    container.innerHTML = `<div class="simple-chart text-muted"><i class="fas fa-info-circle"></i> ${message}</div>`;
}
function createAlertTypesChart(aggregates) {
    const containerId = 'alertTypesChart';
    if (!document.getElementById(containerId)) return;
    if (!aggregates.alertByEvent.length) {
        showNoData(containerId, 'No alert type data available for this filter');
        return;
    }
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'pie', height: 350 },
        title: { text: null },
        plotOptions: {
            pie: {
                allowPointSelect: true,
                cursor: 'pointer',
                dataLabels: {
                    enabled: true,
                    format: '<b>{point.name}</b><br>{point.percentage:.1f}%'
                },
                showInLegend: true
            }
        },
        series: [{
            name: 'Alerts',
            data: aggregates.alertByEvent.map(item => ({
                name: item.event || 'Unknown',
                y: item.count || 0
            }))
        }]
    }));
}

function createSeverityChart(aggregates) {
    const containerId = 'severityChart';
    if (!document.getElementById(containerId)) return;
    if (!aggregates.alertBySeverity.length) {
        showNoData(containerId, 'No severity data available for this filter');
        return;
    }
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'column', height: 350 },
        title: { text: null },
        xAxis: {
            categories: aggregates.alertBySeverity.map(item => item.severity),
            title: { text: 'Severity Level' }
        },
        yAxis: { title: { text: 'Number of Alerts' } },
        plotOptions: {
            column: { colorByPoint: true }
        },
        series: [{
            name: 'Alerts',
            data: aggregates.alertBySeverity.map(item => ({
                name: item.severity,
                y: item.count,
                color: severityColors[item.severity] || severityColors.Unknown
            }))
        }]
    }));
}

function createStatusChart(aggregates) {
    const containerId = 'statusChart';
    if (!document.getElementById(containerId)) return;
    if (!aggregates.alertByStatus.length) {
        showNoData(containerId, 'No status data available for this filter');
        return;
    }
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'pie', height: 350 },
        title: { text: null },
        plotOptions: {
            pie: {
                dataLabels: {
                    enabled: true,
                    format: '<b>{point.name}</b>: {point.y}'
                }
            }
        },
        series: [{
            name: 'Alerts',
            data: aggregates.alertByStatus.map(item => ({
                name: item.status || 'Unknown',
                y: item.count || 0
            }))
        }]
    }));
}
function createTemporalHeatmapChart(aggregates) {
    const containerId = 'temporalHeatmapChart';
    const container = document.getElementById(containerId);
    if (!container) return;
    const matrix = aggregates.hourlyMatrix || [];
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const data = [];
    matrix.forEach((row, dow) => {
        row.forEach((value, hour) => {
            data.push([hour, dow, value || 0]);
        });
    });
    if (!data.some(point => point[2] > 0)) {
        showNoData(containerId, 'No temporal activity for this filter');
        return;
    }
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'heatmap', height: 340 },
        title: { text: null },
        xAxis: {
            categories: Array.from({ length: 24 }, (_, i) => `${i}:00`),
            title: { text: 'Hour of Day' }
        },
        yAxis: {
            categories: dayNames,
            title: { text: 'Day of Week' },
            reversed: true
        },
        colorAxis: {
            min: 0,
            minColor: '#FFFFFF',
            maxColor: '#007bff'
        },
        tooltip: {
            formatter() {
                return `${dayNames[this.point.y]} ${this.point.x}:00 â†’ <b>${this.point.value}</b> alerts`;
            }
        },
        series: [{
            name: 'Alerts per hour',
            borderWidth: 1,
            data,
            dataLabels: {
                enabled: false
            }
        }]
    }));
}

function createDayOfWeekChart(aggregates) {
    const containerId = 'dayOfWeekChart';
    if (!document.getElementById(containerId)) return;
    if (!aggregates.dowTotals.some(value => value > 0)) {
        showNoData(containerId, 'No day-of-week activity for this filter');
        return;
    }
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'column', height: 350 },
        title: { text: null },
        xAxis: {
            categories: dayNames,
            title: { text: 'Day of Week' }
        },
        yAxis: { title: { text: 'Number of Alerts' } },
        series: [{
            name: 'Alerts',
            data: aggregates.dowTotals,
            color: '#28a745'
        }]
    }));
}

function createMonthlyChart(aggregates) {
    const containerId = 'monthlyChart';
    if (!document.getElementById(containerId)) return;
    if (!aggregates.monthlyTotals.some(value => value > 0)) {
        showNoData(containerId, 'No monthly activity for this filter');
        return;
    }
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'area', height: 350 },
        title: { text: null },
        xAxis: {
            categories: monthNames,
            title: { text: 'Month' }
        },
        yAxis: { title: { text: 'Number of Alerts' } },
        plotOptions: {
            area: {
                fillOpacity: 0.3,
                marker: { enabled: false }
            }
        },
        series: [{
            name: 'Monthly Alerts',
            data: aggregates.monthlyTotals,
            color: '#007bff'
        }]
    }));
}

function createYearlyTrendChart(aggregates) {
    const containerId = 'yearlyTrendChart';
    const container = document.getElementById(containerId);
    if (!container) return;
    const data = aggregates.yearlyTotals && aggregates.yearlyTotals.length ? aggregates.yearlyTotals : (statsData.alertByYear || []);
    if (!data.length) {
        showNoData(containerId, 'Not enough yearly data to plot');
        return;
    }
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'line', height: 300 },
        title: { text: null },
        xAxis: {
            categories: data.map(item => item.year),
            title: { text: 'Year' }
        },
        yAxis: { title: { text: 'Number of Alerts' } },
        plotOptions: {
            line: {
                dataLabels: { enabled: true },
                marker: { enabled: true, radius: 5 }
            }
        },
        series: [{
            name: 'Annual Alerts',
            data: data.map(item => item.count),
            color: '#6f42c1'
        }]
    }));
}

function createRecentActivityChart(aggregates) {
    const containerId = 'recentActivityChart';
    const container = document.getElementById(containerId);
    if (!container) return;
    const series = aggregates.recentByDay.length ? aggregates.recentByDay : (statsData.recentByDay || []);
    if (!series.length) {
        showNoData(containerId, 'No recent activity available');
        return;
    }
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'spline', height: 300 },
        title: { text: null },
        xAxis: {
            categories: series.map(item => new Date(item.date).toLocaleDateString()),
            title: { text: 'Date' }
        },
        yAxis: { title: { text: 'Number of Alerts' } },
        plotOptions: {
            spline: {
                marker: { enabled: true, radius: 4 },
                lineWidth: 3
            }
        },
        series: [{
            name: 'Daily Alerts',
            data: series.map(item => item.count),
            color: '#20c997'
        }]
    }));
}
function createMultiTimelineChart(aggregates) {
    const containerId = 'multiTimelineChart';
    const container = document.getElementById(containerId);
    if (!container) return;
    const comparison = aggregates.timelineComparison;
    if (!comparison) {
        showNoData(containerId, 'Not enough timeline data to compare weeks');
        return;
    }
    const toSeries = points => points.map(point => [new Date(point.date).getTime(), point.count]);
    const series = [
        { name: 'Current Week', data: toSeries(comparison.currentWeek), color: '#007bff' },
        { name: 'Previous Week', data: toSeries(comparison.previousWeek), color: '#20c997' },
        { name: 'Same Week Last Year', data: toSeries(comparison.lastYearWeek), color: '#6c757d' }
    ];
    const movingAverages = [
        { name: '7-day Avg', data: comparison.movingAverages.sevenDay.map(p => [new Date(p.date).getTime(), p.value]), color: '#fd7e14', dashStyle: 'ShortDash' },
        { name: '30-day Avg', data: comparison.movingAverages.thirtyDay.map(p => [new Date(p.date).getTime(), p.value]), color: '#dc3545', dashStyle: 'Dot' }
    ];
    createOrUpdateChart(containerId, () => Highcharts.stockChart(containerId, {
        rangeSelector: { enabled: false },
        navigator: { enabled: false },
        scrollbar: { enabled: false },
        title: { text: null },
        xAxis: { type: 'datetime' },
        yAxis: { title: { text: 'Alerts' } },
        series: [...series, ...movingAverages]
    }));
    const annotations = document.getElementById('timelineAnnotations');
    if (annotations) {
        annotations.textContent = comparison.annotations.length ? comparison.annotations.map(item => `${new Date(item.date).toLocaleDateString()}: ${item.text}`).join(' | ') : 'No notable peaks detected in this range.';
    }
}

function createForecastChart(aggregates) {
    const containerId = 'forecastChart';
    const container = document.getElementById(containerId);
    if (!container) return;
    const forecast = aggregates.forecast;
    if (!forecast) {
        showNoData(containerId, 'Need more history to forecast alerts');
        return;
    }
    const actualSeries = aggregates.dailySeries.slice(-30).map(item => [new Date(item.date).getTime(), item.count]);
    const projectionSeries = forecast.projection.map(item => [new Date(item.date).getTime(), item.value]);
    const lowerBand = forecast.projection.map(item => [new Date(item.date).getTime(), item.lower]);
    const upperBand = forecast.projection.map(item => [new Date(item.date).getTime(), item.upper]);

    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'areaspline', height: 350 },
        title: { text: null },
        xAxis: { type: 'datetime' },
        yAxis: { title: { text: 'Alerts' } },
        tooltip: { shared: true },
        series: [
            { name: 'Last 30 Days', type: 'spline', data: actualSeries, color: '#007bff', marker: { enabled: false } },
            {
                name: 'Confidence Interval',
                type: 'arearange',
                data: upperBand.map((point, idx) => [point[0], lowerBand[idx][1], point[1]]),
                color: 'rgba(0, 123, 255, 0.15)',
                lineWidth: 0,
                linkedTo: ':previous'
            },
            { name: 'Projected', type: 'spline', data: projectionSeries, color: '#dc3545', dashStyle: 'ShortDash', marker: { enabled: true } }
        ]
    }));
    const summary = document.getElementById('forecastSummary');
    if (summary) {
        summary.textContent = `Expected alerts next 7 days: ${forecast.expectedNext7}`;
    }
}

function createMasterDetailChart(aggregates) {
    const containerId = 'masterDetailChart';
    const container = document.getElementById(containerId);
    if (!container) return;
    const masterDetail = aggregates.masterDetail;
    if (!masterDetail || !masterDetail.baseSeries.length) {
        showNoData(containerId, 'Not enough alert variety to build drilldown');
        return;
    }
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'column', height: 350 },
        title: { text: null },
        xAxis: { type: 'category' },
        yAxis: { title: { text: 'Alerts' } },
        legend: { enabled: false },
        drilldown: { series: masterDetail.drilldownSeries },
        series: [{
            name: 'Alerts',
            colorByPoint: true,
            data: masterDetail.baseSeries
        }]
    }));
}

function createLifecycleChart(filteredAlerts) {
    const containerId = 'lifecycleChart';
    const container = document.getElementById(containerId);
    if (!container) return;
    const alerts = filteredAlerts
        .filter(alert => alert.sentDate)
        .sort((a, b) => b.sentDate - a.sentDate)
        .slice(0, 25);
    if (!alerts.length) {
        showNoData(containerId, 'No alerts with lifecycle data in this filter');
        return;
    }
    const categories = alerts.map(alert => `${alert.event} (${alert.severity})`);
    const points = alerts.map((alert, index) => {
        const start = alert.sentDate.getTime();
        const end = alert.expiresDate ? alert.expiresDate.getTime() : start + (60 * 60 * 1000);
        return {
            x: start,
            x2: end,
            y: index,
            color: severityColors[alert.severity] || severityColors.Unknown,
            name: alert.event
        };
    });
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'xrange', height: 400 },
        title: { text: null },
        xAxis: { type: 'datetime', title: { text: 'Timeline' } },
        yAxis: {
            categories,
            reversed: true,
            title: { text: null }
        },
        tooltip: {
            pointFormatter() {
                const start = new Date(this.x).toLocaleString();
                const end = new Date(this.x2).toLocaleString();
                return `<b>${this.name}</b><br>Start: ${start}<br>End: ${end}`;
            }
        },
        series: [{
            name: 'Alert Lifecycle',
            borderColor: 'rgba(0,0,0,0.15)',
            data: points
        }]
    }));
}
function createAffectedAreasChart() {
    const containerId = 'affectedAreasChart';
    const container = document.getElementById(containerId);
    if (!container) return;
    if (!statsData.mostAffectedBoundaries || !statsData.mostAffectedBoundaries.length) {
        showNoData(containerId, 'No boundary impact data available');
        return;
    }
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'bar', height: 400 },
        title: { text: null },
        xAxis: {
            categories: statsData.mostAffectedBoundaries.map(item => item.name),
            title: { text: 'Boundary' }
        },
        yAxis: { title: { text: 'Number of Alerts' } },
        series: [{
            name: 'Alert Count',
            data: statsData.mostAffectedBoundaries.map(item => item.count),
            color: '#17a2b8'
        }]
    }));
}

function createBoundaryTypesChart() {
    const containerId = 'boundaryTypesChart';
    const container = document.getElementById(containerId);
    if (!container) return;
    if (!statsData.boundaryStats || !statsData.boundaryStats.length) {
        showNoData(containerId, 'No boundary types data available');
        return;
    }
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'pie', height: 350 },
        title: { text: null },
        plotOptions: {
            pie: { dataLabels: { enabled: true } }
        },
        series: [{
            name: 'Boundary Types',
            data: statsData.boundaryStats.map(item => ({ name: item.type, y: item.count }))
        }]
    }));
}

function createReliabilityGauge() {
    const containerId = 'reliabilityGauge';
    const container = document.getElementById(containerId);
    if (!container || !statsData.polling || typeof statsData.polling.success_rate === 'undefined') return;
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'solidgauge', height: 300 },
        title: { text: null },
        pane: {
            center: ['50%', '85%'],
            size: '140%',
            startAngle: -90,
            endAngle: 90,
            background: {
                backgroundColor: '#EEE',
                innerRadius: '60%',
                outerRadius: '100%',
                shape: 'arc'
            }
        },
        yAxis: {
            min: 0,
            max: 1,
            stops: [
                [0.1, '#dc3545'],
                [0.5, '#ffc107'],
                [0.9, '#28a745']
            ],
            lineWidth: 0,
            tickWidth: 0,
            minorTickInterval: null,
            tickAmount: 2,
            title: { y: -70, text: 'System Reliability' },
            labels: {
                y: 16,
                formatter() {
                    return Math.round(this.value * 100) + '%';
                }
            }
        },
        series: [{
            name: 'Reliability',
            data: [statsData.polling.success_rate || 0],
            dataLabels: {
                format: '<div style="text-align:center"><span style="font-size:24px">{y:.1%}</span><br/><span style="font-size:12px;color:silver">Uptime</span></div>'
            }
        }]
    }));
}

function createDurationChart() {
    const containerId = 'durationChart';
    const container = document.getElementById(containerId);
    if (!container || !statsData.avgDurations || !statsData.avgDurations.length) return;
    createOrUpdateChart(containerId, () => Highcharts.chart(containerId, {
        chart: { type: 'column', height: 350 },
        title: { text: null },
        xAxis: {
            categories: statsData.avgDurations.map(item => item.event),
            title: { text: 'Alert Type' }
        },
        yAxis: { title: { text: 'Average Duration (hours)' } },
        series: [{
            name: 'Duration',
            data: statsData.avgDurations.map(item => Math.round(item.avg_hours * 10) / 10),
            color: '#fd7e14'
        }]
    }));
}

function renderDynamicCharts(aggregates) {
    createAlertTypesChart(aggregates);
    createSeverityChart(aggregates);
    createStatusChart(aggregates);
    createTemporalHeatmapChart(aggregates);
    createDayOfWeekChart(aggregates);
    createMonthlyChart(aggregates);
    createYearlyTrendChart(aggregates);
    createRecentActivityChart(aggregates);
    createMultiTimelineChart(aggregates);
    createForecastChart(aggregates);
    createMasterDetailChart(aggregates);
    createLifecycleChart(state.filteredAlerts);
}

function renderStaticCharts() {
    createAffectedAreasChart();
    createBoundaryTypesChart();
    createReliabilityGauge();
    createDurationChart();
}

function updateSystemInfo() {
    const timestamp = document.getElementById('stats-timestamp');
    if (timestamp) {
        timestamp.textContent = new Date().toLocaleString();
    }
    const uptimeDays = document.getElementById('uptime-days');
    if (uptimeDays) {
        const startDate = new Date('2025-01-01T00:00:00');
        const now = new Date();
        const days = Math.max(0, Math.floor((now - startDate) / (1000 * 60 * 60 * 24)));
        uptimeDays.textContent = days.toLocaleString();
    }
}

function updateDashboard() {
    state.filteredAlerts = getFilteredAlerts();
    updateFilterSummary(state.filteredAlerts);
    state.aggregates = aggregateAlerts(state.filteredAlerts, state.filters);
    updateQuickStats(state.aggregates);
    updateKpiCards(state.aggregates);
    renderSparklines(state.aggregates);
    renderDynamicCharts(state.aggregates);
    if (!state.staticChartsInitialized) {
        renderStaticCharts();
        state.staticChartsInitialized = true;
    }
}

function initializeFilters() {
    populateFilterSelect('severityFilter', statsData.filterOptions.severities || []);
    populateFilterSelect('statusFilter', statsData.filterOptions.statuses || []);
    populateFilterSelect('eventFilter', statsData.filterOptions.events || []);

    const presetSelect = document.getElementById('dateRangePreset');
    if (presetSelect) {
        presetSelect.addEventListener('change', handlePresetChange);
    }
    const applyBtn = document.getElementById('applyFiltersBtn');
    if (applyBtn) {
        applyBtn.addEventListener('click', () => {
            if (presetSelect && presetSelect.value === 'custom') {
                state.filters.preset = 'custom';
            }
            applyFiltersFromInputs();
        });
    }
    const resetBtn = document.getElementById('resetFiltersBtn');
    if (resetBtn) {
        resetBtn.addEventListener('click', resetFilters);
    }
    const exportBtn = document.getElementById('exportDashboardBtn');
    if (exportBtn) {
        exportBtn.addEventListener('click', exportFilteredData);
    }

    setPresetDates('last30');
    updateDateInputs();
}

function initializeDashboard() {
    if (window.__statsDashboardInitialized) {
        console.warn('Statistics dashboard initialization skipped because it already ran.');
        return;
    }

    window.__statsDashboardInitialized = true;
    configureHighchartsDefaults();
    updateSystemInfo();
    initializeFilters();
    updateDashboard();
    console.log('ðŸ“Š Dashboard ready');
}

function renderInitializationFailure(message) {
    const root = document.getElementById('statisticsDashboardRoot');
    if (root) {
        let alert = root.querySelector('.stats-init-error');
        if (!alert) {
            alert = document.createElement('div');
            alert.className = 'alert alert-danger mt-3 stats-init-error';
            root.prepend(alert);
        }
        alert.innerHTML = `<strong>${message}</strong> Please check the browser console for details.`;
    }
    if (typeof showToast === 'function') {
        showToast(message, 'error', 8000);
    }
}

function handleInitializationError(error, message) {
    console.error('âŒ Statistics dashboard failed to initialize', error);
    window.__statsDashboardInitialized = false;
    renderInitializationFailure(message || 'Statistics failed to load.');
}

document.addEventListener('DOMContentLoaded', () => {
    const highchartsPromise = window.__highchartsLoadPromise;

    if (!highchartsPromise) {
        handleInitializationError(new Error('Highcharts loader was not initialized.'), 'Statistics failed to load because the charting library was not requested.');
        return;
    }

    highchartsPromise
        .then(() => {
            try {
                initializeDashboard();
            } catch (error) {
                handleInitializationError(error, 'Statistics failed to load.');
            }
        })
        .catch((error) => {
            handleInitializationError(error, 'Statistics failed to load because the charting library could not be loaded.');
        });
});
</script>
