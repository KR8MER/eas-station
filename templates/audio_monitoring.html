{% extends "base.html" %}

{% block title %}Audio Monitoring - EAS Station{% endblock %}

{% block content %}
<div class="row mb-3">
    <div class="col-12">
        <h2><i class="fas fa-headphones"></i> Audio Monitoring</h2>
        <p class="text-muted">Listen to live audio from configured sources</p>
    </div>
</div>

<div class="row mb-3">
    <div class="col-12">
        <div class="alert alert-info">
            <i class="fas fa-info-circle"></i>
            <strong>Live Audio Monitoring:</strong> Audio sources must be running to stream audio. Use the start button if a source is stopped.
            <br>
            <strong>Background Monitoring:</strong> EAS alert detection, waveform visualization, and audio level monitoring run continuously in the background, independent of web playback.
            Even if you pause or stop web playback, the system continues monitoring for alerts 24/7.
        </div>
    </div>
</div>

<div id="audio-sources-container" class="row">
    <div class="col-12 text-center">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="text-muted mt-2">Loading audio sources...</p>
    </div>
</div>

<style>
.audio-source-card {
    border-left: 4px solid #0d6efd;
    transition: all 0.3s ease;
}

.audio-source-card.status-running {
    border-left-color: #28a745;
}

.audio-source-card.status-stopped {
    border-left-color: #6c757d;
}

.audio-source-card.status-error {
    border-left-color: #dc3545;
}

.audio-source-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.audio-player-container {
    background: #f8f9fa;
    padding: 1rem;
    border-radius: 8px;
    margin-top: 1rem;
}

.audio-player-container audio {
    width: 100%;
    height: 54px;
}

.status-badge {
    font-size: 0.875rem;
    padding: 0.375rem 0.75rem;
}

.metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 0.75rem;
    margin-top: 1rem;
}

.metric-item {
    background: #e9ecef;
    padding: 0.75rem;
    border-radius: 6px;
    text-align: center;
}

.metric-label {
    font-size: 0.75rem;
    color: #6c757d;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.metric-value {
    font-size: 1.25rem;
    font-weight: bold;
    color: #212529;
}

.now-playing-title {
    font-size: 1rem;
    font-weight: 600;
    line-height: 1.35;
}

.now-playing-artist {
    font-size: 0.95rem;
    color: #495057;
}

.now-playing-meta {
    font-size: 0.85rem;
    color: #6c757d;
}

.level-meter {
    height: 20px;
    background: linear-gradient(to right, #28a745, #ffc107, #dc3545);
    border-radius: 10px;
    position: relative;
    overflow: hidden;
}

.level-indicator {
    position: absolute;
    left: 50%;
    top: 0;
    bottom: 0;
    width: 2px;
    background: #000;
    transform: translateX(-50%);
}

.vu-meter {
    background: #101010;
    border-radius: 10px;
    padding: 0.75rem;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.04);
}

.vu-track {
    position: relative;
    height: 14px;
    border-radius: 7px;
    background: linear-gradient(90deg, #1e7e34, #ffc107 70%, #dc3545);
    overflow: hidden;
}

.vu-fill {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 0%;
    background: rgba(255, 255, 255, 0.75);
    box-shadow: 0 0 6px rgba(255,255,255,0.4);
    transition: width 0.15s ease-out, opacity 0.15s ease-out;
}

.vu-fill.rms {
    background: rgba(0, 198, 255, 0.75);
    box-shadow: 0 0 6px rgba(0,198,255,0.4);
}

.vu-labels {
    font-size: 0.85rem;
    color: #adb5bd;
}

.vu-labels span {
    font-variant-numeric: tabular-nums;
}
</style>

<script>
let audioSources = [];
let levelIntervalHandle = null;
const htmlEntityDecoder = document.createElement('textarea');

// Fetch audio sources from API
async function loadAudioSources() {
    try {
        const response = await fetch('/api/audio/sources');
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        audioSources = data.sources || [];
        renderAudioSources();
        startLevelPolling();
    } catch (error) {
        console.error('Failed to load audio sources:', error);
        document.getElementById('audio-sources-container').innerHTML = `
            <div class="col-12">
                <div class="alert alert-danger">
                    <strong>Error loading audio sources:</strong> ${error.message}
                    <div class="small text-muted mt-1">Check that you are signed in and the audio API is reachable.</div>
                </div>
            </div>
        `;
    }
}

function renderAudioSources() {
    const container = document.getElementById('audio-sources-container');

    if (audioSources.length === 0) {
        container.innerHTML = `
            <div class="col-12">
                <div class="alert alert-warning">
                    <i class="fas fa-exclamation-triangle"></i>
                    No audio sources configured. Please configure audio sources in the Audio Settings page.
                </div>
            </div>
        `;
        return;
    }

    // Save playing state of audio players before re-render
    const playingStates = {};
    const currentTimes = {};
    audioSources.forEach(source => {
        const audioEl = document.getElementById(`audio-${source.name}`);
        if (audioEl) {
            playingStates[source.name] = !audioEl.paused;
            currentTimes[source.name] = audioEl.currentTime;
        }
    });

    container.innerHTML = audioSources.map(source => {
        const safeId = sanitizeId(source.name);
        const peakValue = source.metrics?.peak_level_db;
        const rmsValue = source.metrics?.rms_level_db;

        return `
        <div class="col-lg-6 col-xl-4 mb-3">
            <div class="card audio-source-card status-${source.status}">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">
                            <i class="fas fa-${getSourceIcon(source.type)}"></i>
                            ${escapeHtml(source.name)}
                        </h5>
                        <div>
                            <span class="badge status-badge bg-${getStatusColor(source.status)}">
                                ${source.status.toUpperCase()}
                            </span>
                            ${source.status === 'running' ? `
                                <span class="badge bg-info ms-1" title="Background monitoring (EAS detection, waveforms, audio levels) is active">
                                    <i class="fas fa-eye"></i> Monitoring
                                </span>
                            ` : ''}
                        </div>
                    </div>
                    <small class="text-muted">${escapeHtml(source.type.toUpperCase())} Source</small>
                </div>
                <div class="card-body">
                    ${source.description ? `<p class="text-muted">${escapeHtml(source.description)}</p>` : ''}

                    <!-- Live level meter -->
                    <div class="vu-meter" aria-live="polite">
                        <div class="d-flex justify-content-between vu-labels mb-2">
                            <span id="peak-label-${safeId}">Peak: ${formatDbLabel(peakValue)}</span>
                            <span id="rms-label-${safeId}">RMS: ${formatDbLabel(rmsValue)}</span>
                        </div>
                        <div class="vu-track" role="presentation">
                            <div class="vu-fill" id="peak-meter-${safeId}" style="width: ${calculateFillWidth(peakValue)}%"></div>
                            <div class="vu-fill rms" id="rms-meter-${safeId}" style="width: ${calculateFillWidth(rmsValue)}%"></div>
                        </div>
                    </div>

                    <!-- Audio Player -->
                    <div class="audio-player-container" id="player-container-${source.name}">
                        ${source.status === 'running' ? `
                            <audio
                                controls
                                id="audio-${source.name}"
                                preload="none"
                                data-source-name="${escapeHtml(source.name)}"
                                data-icecast-url="${source.icecast_url ? escapeHtml(source.icecast_url) : ''}"
                                data-proxy-url="/api/audio/stream/${encodeURIComponent(source.name)}"
                                data-initial-stream-type="${source.icecast_url ? 'icecast' : 'flask-proxy'}">
                                Your browser does not support the audio element.
                            </audio>
                            <div class="audio-player-status small mt-2 text-muted" id="player-status-${source.name}"></div>
                            ${source.icecast_url ? `
                                <small class="text-success d-block mt-1">
                                    <i class="fas fa-broadcast-tower"></i> Professional Streaming (Icecast) - Better quality, no dropouts
                                    ${source.streaming && source.streaming.icecast ? `
                                        <span class="d-block text-muted small mt-1">
                                            ${typeof source.streaming.icecast.bitrate_kbps === 'number' ? `${Number(source.streaming.icecast.bitrate_kbps).toFixed(1)} kbps` : ''}
                                            ${typeof source.streaming.icecast.uptime_seconds === 'number' ? `
                                                <span class="ms-2">
                                                    <i class="fas fa-clock"></i> Uptime ${Math.floor(source.streaming.icecast.uptime_seconds / 60)}m
                                                </span>
                                            ` : ''}
                                        </span>
                                    ` : ''}
                                    <span class="d-block text-muted small mt-1">
                                        <i class="fas fa-shield-alt"></i> HTTPS dashboards automatically fall back to the secure built-in player if Icecast is HTTP-only.
                                    </span>
                                </small>
                            ` : `
                                <small class="text-muted d-block mt-1">
                                    <i class="fas fa-info-circle"></i> Basic Streaming Mode
                                    <span class="d-block small text-muted mt-1">A secure built-in player is used automatically on HTTPS deployments.</span>
                                    <a href="/settings/audio#icecast" class="d-inline-flex align-items-center gap-1 text-primary mt-1">
                                        <i class="fas fa-arrow-up-right-from-square"></i>
                                        <span>Enable Icecast for professional quality</span>
                                    </a>
                                </small>
                            `}
                        ` : `
                            <div class="alert alert-secondary mb-0">
                                <i class="fas fa-pause-circle"></i>
                                Audio source is ${source.status}. ${source.error_message ? `Error: ${escapeHtml(source.error_message)}` : 'Start the source to listen.'}
                            </div>
                        `}
                    </div>

                    <!-- Metrics -->
                    ${source.status === 'running' && source.metrics ? `
                        <div class="metrics-grid">
                            <div class="metric-item">
                                <div class="metric-label">Peak</div>
                                <div class="metric-value">${source.metrics.peak_level_db.toFixed(1)} dB</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-label">RMS</div>
                                <div class="metric-value">${source.metrics.rms_level_db.toFixed(1)} dB</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-label">Sample Rate</div>
                                <div class="metric-value">${(source.metrics.sample_rate / 1000).toFixed(1)} kHz</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-label">Channels</div>
                                <div class="metric-value">${source.metrics.channels}</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-label">Buffer</div>
                                <div class="metric-value">${(source.metrics.buffer_utilization * 100).toFixed(0)}%</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-label">Frames</div>
                                <div class="metric-value">${(source.metrics.frames_captured || 0).toLocaleString()}</div>
                            </div>
                        </div>

                        <!-- Buffer Utilization Indicator -->
                        <div class="mt-2">
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <small class="text-muted">Buffer Utilization</small>
                                <small class="text-muted">${(source.metrics.buffer_utilization * 100).toFixed(1)}%</small>
                            </div>
                            <div class="progress" style="height: 6px;">
                                <div class="progress-bar ${source.metrics.buffer_utilization > 0.8 ? 'bg-warning' : source.metrics.buffer_utilization > 0.95 ? 'bg-danger' : 'bg-success'}"
                                     role="progressbar"
                                     style="width: ${(source.metrics.buffer_utilization * 100).toFixed(1)}%"
                                     aria-valuenow="${(source.metrics.buffer_utilization * 100).toFixed(1)}"
                                     aria-valuemin="0"
                                     aria-valuemax="100"></div>
                            </div>
                            <small class="text-muted">
                                ${source.metrics.buffer_utilization < 0.01 ? '⚠️ No data flowing' :
                                  source.metrics.buffer_utilization > 0.95 ? '⚠️ Buffer nearly full' :
                                  '✓ Data flowing normally'}
                            </small>
                        </div>

                        <!-- Now Playing (if available) -->
                        ${(() => {
                            const nowPlaying = normalizeNowPlayingMetadata(source.metrics.metadata);
                            if (!nowPlaying) {
                                return '';
                            }

                            const { artworkUrl, title, artist, album, length } = nowPlaying;

                            return `
                                <div class="mt-3">
                                    <h6 class="text-muted mb-2"><i class="fas fa-music"></i> Now Playing</h6>
                                    <div class="card bg-light border-0">
                                        <div class="card-body p-3">
                                            <div class="row align-items-center">
                                                ${artworkUrl ? `
                                                    <div class="col-auto">
                                                        <img src="${escapeHtml(artworkUrl)}"
                                                             alt="Album Art"
                                                             class="img-thumbnail"
                                                             style="width: 100px; height: 100px; object-fit: cover;"
                                                             onerror="this.style.display='none'">
                                                    </div>
                                                ` : ''}
                                                <div class="col">
                                                    ${title ? `<div class="now-playing-title text-break">${escapeHtml(title)}</div>` : ''}
                                                    ${artist ? `<div class="now-playing-artist text-break">${escapeHtml(artist)}</div>` : ''}
                                                    ${album ? `<div class="now-playing-meta text-break"><i class="fas fa-compact-disc"></i> ${escapeHtml(album)}</div>` : ''}
                                                    ${length ? `<div class="now-playing-meta text-break"><i class="fas fa-clock"></i> ${escapeHtml(length)}</div>` : ''}
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        })()}

                        <!-- Stream Metadata (if available) -->
                                    ${source.metrics.metadata ? `
                                        <div class="mt-3">
                                            <h6 class="text-muted mb-2"><i class="fas fa-info-circle"></i> Stream Information</h6>
                                            <div class="small">
                                                ${source.metrics.metadata.receiver_display_name ? `
                                                    <div class="d-flex justify-content-between mb-1">
                                                        <span class="text-muted">Receiver:</span>
                                                        <span class="fw-bold">
                                                            ${escapeHtml(source.metrics.metadata.receiver_display_name)}
                                                            ${source.metrics.metadata.receiver_identifier ? `
                                                                <span class="text-muted small ms-2">${escapeHtml(source.metrics.metadata.receiver_identifier)}</span>
                                                            ` : ''}
                                                        </span>
                                                    </div>
                                                ` : ''}
                                                ${source.metrics.metadata.receiver_frequency_display ? `
                                                    <div class="d-flex justify-content-between mb-1">
                                                        <span class="text-muted">Frequency:</span>
                                                        <span>${escapeHtml(source.metrics.metadata.receiver_frequency_display)}</span>
                                                    </div>
                                                ` : ''}
                                                ${source.metrics.metadata.receiver_modulation ? `
                                                    <div class="d-flex justify-content-between mb-1">
                                                        <span class="text-muted">Mode:</span>
                                                        <span class="text-uppercase">${escapeHtml(source.metrics.metadata.receiver_modulation)}</span>
                                                    </div>
                                                ` : ''}
                                                ${source.metrics.metadata.receiver_driver ? `
                                                    <div class="d-flex justify-content-between mb-1">
                                                        <span class="text-muted">Driver:</span>
                                                        <span class="font-monospace small">${escapeHtml(source.metrics.metadata.receiver_driver)}</span>
                                                    </div>
                                                ` : ''}
                                                ${source.metrics.metadata.codec ? `
                                                    <div class="d-flex justify-content-between mb-1">
                                                        <span class="text-muted">Codec:</span>
                                                        <span class="fw-bold text-uppercase">
                                                            ${escapeHtml(source.metrics.metadata.codec)}
                                                ${source.metrics.metadata.codec_version ? `
                                                    <span class="badge bg-secondary text-white small ms-1">${escapeHtml(source.metrics.metadata.codec_version)}</span>
                                                ` : ''}
                                            </span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.bitrate_kbps ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">Bitrate:</span>
                                            <span class="fw-bold">
                                                ${source.metrics.metadata.bitrate_kbps} kbps
                                                ${source.metrics.metadata.is_vbr ? `
                                                    <span class="badge bg-info text-white small ms-1">VBR</span>
                                                ` : ''}
                                            </span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.icy_name ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">Station:</span>
                                            <span class="fw-bold">${escapeHtml(source.metrics.metadata.icy_name)}</span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.icy_genre ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">Genre:</span>
                                            <span>${escapeHtml(source.metrics.metadata.icy_genre)}</span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.stream_url ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">URL:</span>
                                            <span class="font-monospace small text-break">${escapeHtml(source.metrics.metadata.stream_url)}</span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.icecast_stream_url && source.metrics.metadata.icecast_stream_url !== source.metrics.metadata.stream_url ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">Icecast URL:</span>
                                            <span class="font-monospace small text-break">${escapeHtml(source.metrics.metadata.icecast_stream_url)}</span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.icecast_server ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">Icecast Server:</span>
                                            <span class="font-monospace small text-break">${escapeHtml(source.metrics.metadata.icecast_server)}${source.metrics.metadata.icecast_port ? `:${source.metrics.metadata.icecast_port}` : ''}</span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.icecast_mount ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">Mount:</span>
                                            <span class="font-monospace small text-break">${escapeHtml(source.metrics.metadata.icecast_mount)}</span>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        ` : ''}
                    ` : ''}

                    <!-- Control Buttons -->
                    <div class="mt-3 d-flex gap-2">
                        ${source.status !== 'running' ? `
                            <button class="btn btn-success btn-sm" onclick="startSource('${source.name}')">
                                <i class="fas fa-play"></i> Start
                            </button>
                        ` : `
                            <button class="btn btn-danger btn-sm" onclick="stopSource('${source.name}')">
                                <i class="fas fa-stop"></i> Stop
                            </button>
                        `}
                        <button class="btn btn-outline-primary btn-sm" onclick="loadAudioSources()">
                            <i class="fas fa-sync"></i> Refresh
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;}).join('');

    initializeAudioPlayers(playingStates, currentTimes);
}

function sanitizeId(text) {
    return (text || '').toString().replace(/[^a-zA-Z0-9_-]/g, '-');
}

function formatDbLabel(value) {
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return '-- dBFS';
    }
    return `${value.toFixed(1)} dBFS`;
}

function calculateFillWidth(value) {
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return 0;
    }
    const MIN_DB = -60;
    const MAX_DB = 0;
    const clamped = Math.max(MIN_DB, Math.min(MAX_DB, value));
    return ((clamped - MIN_DB) / (MAX_DB - MIN_DB)) * 100;
}

function initializeAudioPlayers(playingStates = {}, currentTimes = {}) {
    audioSources.forEach(source => {
        if (source.status !== 'running') {
            setPlayerStatus(source.name, '', 'muted');
            return;
        }

        const audioEl = document.getElementById(`audio-${source.name}`);
        if (!audioEl) {
            return;
        }

        audioEl.dataset.sourceName = source.name;
        if (!audioEl.dataset.proxyUrl) {
            audioEl.dataset.proxyUrl = `/api/audio/stream/${encodeURIComponent(source.name)}`;
        }

        bindAudioPlayerEvents(audioEl);

        const wasPlaying = Boolean(playingStates[source.name]);
        const preferIcecast = shouldUseIcecastStream(audioEl);

        if (preferIcecast) {
            const icecastUrl = audioEl.dataset.icecastUrl;
            audioEl.dataset.streamType = 'icecast';

            if (icecastUrl && audioEl.src !== icecastUrl) {
                audioEl.src = icecastUrl;
                audioEl.dataset.suppressPauseMessage = '1';
                audioEl.load();
            }

            setPlayerStatus(source.name, 'Ready. Press play to listen via Icecast.', 'muted');

            if (wasPlaying) {
                const resumeTime = currentTimes[source.name] || 0;
                if (resumeTime > 0 && !Number.isNaN(resumeTime)) {
                    try {
                        audioEl.currentTime = resumeTime;
                    } catch (err) {
                        console.debug(`Unable to restore playback position for ${source.name}:`, err.message);
                    }
                }

                audioEl.play().catch(err => {
                    console.debug(`Could not auto-resume playback for ${source.name}:`, err.message);
                });
            }

            return;
        }

        const fallbackReason = audioEl.dataset.icecastUrl ? 'Icecast stream is unavailable on secure connections.' : '';

        switchToProxyStream(audioEl, source.name, {
            autoplay: wasPlaying,
            reason: fallbackReason,
            notify: !wasPlaying
        });
    });
}

function bindAudioPlayerEvents(audioEl) {
    if (audioEl.dataset.handlersBound === '1') {
        return;
    }

    const sourceName = audioEl.dataset.sourceName || '';

    audioEl.addEventListener('loadstart', () => {
        clearStreamRecoveryTimer(audioEl);
        setPlayerStatus(sourceName, 'Connecting to stream…', 'info');
    });

    audioEl.addEventListener('playing', () => {
        audioEl.dataset.fallbackRetries = '0';
        clearStreamRecoveryTimer(audioEl);
        setPlayerStatus(sourceName, `${labelForStreamType(audioEl.dataset.streamType)} playing.`, 'success');
    });

    audioEl.addEventListener('waiting', () => {
        setPlayerStatus(sourceName, 'Buffering…', 'info');
        scheduleStreamRecovery(audioEl, sourceName);
    });

    audioEl.addEventListener('stalled', () => {
        setPlayerStatus(sourceName, 'Stream stalled – attempting to recover…', 'warning');
        scheduleStreamRecovery(audioEl, sourceName);
    });

    audioEl.addEventListener('pause', () => {
        if (!audioEl.dataset.suppressPauseMessage) {
            setPlayerStatus(sourceName, 'Playback paused.', 'muted');
        }
        audioEl.dataset.suppressPauseMessage = '';
        clearStreamRecoveryTimer(audioEl);
    });

    audioEl.addEventListener('ended', () => {
        setPlayerStatus(sourceName, 'Stream ended.', 'muted');
    });

    audioEl.addEventListener('error', onAudioPlaybackError);

    audioEl.dataset.handlersBound = '1';
}

function shouldUseIcecastStream(audioEl) {
    const icecastUrl = audioEl.dataset.icecastUrl;
    if (!icecastUrl) {
        return false;
    }

    if (window.location.protocol === 'https:' && /^http:\/\//i.test(icecastUrl)) {
        return false;
    }

    return true;
}

function switchToProxyStream(audioEl, sourceName, options = {}) {
    const { autoplay = false, reason = '', notify = true } = options;
    const proxyUrl = audioEl.dataset.proxyUrl || `/api/audio/stream/${encodeURIComponent(sourceName)}`;

    audioEl.dataset.streamType = 'flask-proxy';
    audioEl.dataset.fallbackActive = audioEl.dataset.icecastUrl ? '1' : audioEl.dataset.fallbackActive;

    const finalUrl = appendCacheBuster(proxyUrl);
    if (audioEl.src !== finalUrl) {
        audioEl.src = finalUrl;
    }
    audioEl.dataset.suppressPauseMessage = '1';
    audioEl.load();

    if (notify) {
        if (audioEl.dataset.icecastUrl) {
            const baseMessage = 'Using secure fallback stream.';
            const message = reason ? `${reason} ${baseMessage}`.trim() : baseMessage;
            setPlayerStatus(sourceName, message, reason ? 'warning' : 'info');
        } else {
            setPlayerStatus(sourceName, 'Ready. Press play to listen.', 'muted');
        }
    }

    if (autoplay) {
        const playPromise = audioEl.play();
        if (playPromise && typeof playPromise.then === 'function') {
            playPromise.then(() => {
                setPlayerStatus(sourceName, `${labelForStreamType(audioEl.dataset.streamType)} playing.`, 'success');
            }).catch(err => {
                console.debug(`Autoplay blocked for ${sourceName}:`, err.message);
                setPlayerStatus(sourceName, audioEl.dataset.icecastUrl
                    ? 'Fallback stream ready. Press play to start listening.'
                    : 'Ready. Press play to listen.',
                    audioEl.dataset.icecastUrl ? 'warning' : 'muted');
            });
        }
    }
}

function appendCacheBuster(url) {
    const separator = url.includes('?') ? '&' : '?';
    return `${url}${separator}ts=${Date.now()}`;
}

function clearStreamRecoveryTimer(audioEl) {
    const timerId = audioEl.dataset.stallTimerId ? parseInt(audioEl.dataset.stallTimerId, 10) : null;
    if (timerId) {
        clearTimeout(timerId);
    }
    audioEl.dataset.stallTimerId = '';
}

function scheduleStreamRecovery(audioEl, sourceName) {
    clearStreamRecoveryTimer(audioEl);

    const streamType = audioEl.dataset.streamType || audioEl.dataset.initialStreamType || 'unknown';
    const wasPlaying = !audioEl.paused;
    const timeoutMs = streamType === 'icecast' ? 3500 : 2000;

    const timerId = window.setTimeout(() => {
        audioEl.dataset.stallTimerId = '';

        const currentType = audioEl.dataset.streamType || audioEl.dataset.initialStreamType || 'unknown';
        if (currentType !== streamType) {
            return;
        }

        if (currentType === 'icecast') {
            const reason = 'Icecast stream stalled or unreachable. Switching to secure fallback.';
            switchToProxyStream(audioEl, sourceName, { autoplay: wasPlaying, reason });
            return;
        }

        if (currentType === 'flask-proxy') {
            setPlayerStatus(sourceName, 'Reconnecting to secure stream…', 'warning');
            switchToProxyStream(audioEl, sourceName, { autoplay: wasPlaying, notify: false });
        }
    }, timeoutMs);

    audioEl.dataset.stallTimerId = String(timerId);
}

function setPlayerStatus(sourceName, message, level = 'muted') {
    const statusEl = document.getElementById(`player-status-${sourceName}`);
    if (!statusEl) {
        return;
    }

    const levelClasses = {
        muted: 'text-muted',
        info: 'text-info',
        success: 'text-success',
        warning: 'text-warning',
        danger: 'text-danger'
    };

    const baseClass = 'audio-player-status small mt-2';
    const levelClass = levelClasses[level] || 'text-muted';

    statusEl.className = `${baseClass} ${levelClass}`;
    statusEl.textContent = message || '';
}

function labelForStreamType(streamType) {
    switch (streamType) {
        case 'icecast':
            return 'Icecast stream';
        case 'flask-proxy':
            return 'Secure built-in stream';
        default:
            return 'Audio stream';
    }
}

function onAudioPlaybackError(event) {
    const audioEl = event.currentTarget;
    const sourceName = audioEl.dataset.sourceName || 'unknown';
    const streamType = audioEl.dataset.streamType || audioEl.dataset.initialStreamType || 'unknown';
    const error = audioEl.error;

    console.warn(`Audio playback error for ${sourceName} (${streamType})`, error);

    if (streamType === 'icecast') {
        const wasPlaying = !audioEl.paused;
        setPlayerStatus(sourceName, 'Icecast stream failed. Switching to secure fallback…', 'warning');
        switchToProxyStream(audioEl, sourceName, {
            autoplay: wasPlaying,
            notify: false
        });
        return;
    }

    if (streamType === 'flask-proxy') {
        const retries = parseInt(audioEl.dataset.fallbackRetries || '0', 10);

        if (retries < 3) {
            audioEl.dataset.fallbackRetries = String(retries + 1);
            const wasPlaying = !audioEl.paused;
            setPlayerStatus(sourceName, 'Reconnecting to secure stream…', 'warning');

            setTimeout(() => {
                switchToProxyStream(audioEl, sourceName, {
                    autoplay: wasPlaying,
                    notify: false
                });
            }, 500);

            return;
        }

        setPlayerStatus(sourceName, 'Unable to connect to audio stream. Please verify the source.', 'danger');
    }
}

function getSourceIcon(type) {
    const icons = {
        'sdr': 'satellite-dish',
        'alsa': 'volume-up',
        'pulse': 'volume-up',
        'file': 'file-audio',
        'stream': 'broadcast-tower'
    };
    return icons[type] || 'question';
}

function getStatusColor(status) {
    const colors = {
        'running': 'success',
        'stopped': 'secondary',
        'starting': 'warning',
        'error': 'danger',
        'disconnected': 'warning'
    };
    return colors[status] || 'secondary';
}

function normalizeNowPlayingMetadata(metadata) {
    if (!metadata) {
        return null;
    }

    const icyFields = metadata.icy && metadata.icy.fields ? metadata.icy.fields : {};
    const streamTitleInfo = parseStreamTitle(icyFields.text);

    const artworkUrl = metadata.artwork_url
        || (metadata.now_playing && metadata.now_playing.artwork_url)
        || (icyFields && icyFields.amgArtworkURL)
        || (icyFields && icyFields.artworkURL);

    const stationIdentifiers = collectStationIdentifiers(metadata, icyFields);

    let title = cleanMetadataValue(
        (metadata.now_playing && metadata.now_playing.title)
        || metadata.song_title
        || metadata.title
        || streamTitleInfo.title
        || streamTitleInfo.text
    );

    let artist = cleanMetadataValue(
        (metadata.now_playing && metadata.now_playing.artist)
        || metadata.artist
        || icyFields.artist
        || streamTitleInfo.artist
    );

    let album = cleanMetadataValue(metadata.album || icyFields.album);
    let length = cleanMetadataValue(metadata.length || icyFields.length || icyFields.duration);

    if (!isMeaningfulMetadataValue(title, stationIdentifiers)) {
        title = '';
    }

    if (!isMeaningfulMetadataValue(artist, stationIdentifiers)) {
        artist = '';
    }

    if (!isMeaningfulMetadataValue(album, stationIdentifiers)) {
        album = '';
    }

    if (title && artist) {
        const titleLower = title.toLowerCase();
        const artistLower = artist.toLowerCase();

        if (titleLower === artistLower) {
            artist = '';
        } else if (titleLower.startsWith(`${artistLower} - `)) {
            title = title.substring(artist.length + 3).trim();
        }
    }

    if (album && title && album.toLowerCase() === title.toLowerCase()) {
        album = '';
    }

    if (length && /^(0|0:00)$/.test(length.trim())) {
        length = '';
    }

    if (!artworkUrl && !title && !artist && !album && !length) {
        return null;
    }

    return { artworkUrl, title, artist, album, length };
}

function parseStreamTitle(rawText) {
    if (!rawText) {
        return {};
    }

    let text = String(rawText).trim();

    const streamTitleMatch = text.match(/StreamTitle='([^']*)'/i);
    if (streamTitleMatch) {
        text = streamTitleMatch[1];
    } else if (text.toLowerCase().startsWith('streamtitle=')) {
        text = text.slice('StreamTitle='.length);
        text = text.replace(/^['"]?/, '').replace(/['"]?$/, '');
    }

    const streamUrlIndex = text.indexOf(';StreamUrl');
    if (streamUrlIndex !== -1) {
        text = text.substring(0, streamUrlIndex);
    }

    text = cleanMetadataValue(text);

    if (!text) {
        return {};
    }

    const parts = text.split(/\s+-\s+/);
    if (parts.length >= 2) {
        return {
            text,
            artist: parts[0].trim(),
            title: parts.slice(1).join(' - ').trim()
        };
    }

    return { text, title: text };
}

function cleanMetadataValue(value) {
    if (value === null || value === undefined) {
        return '';
    }

    let text = String(value).trim();

    if (!text) {
        return '';
    }

    const attributeOnlyMatch = text.match(/^\s*\w+=\s*(?:"([^"]*)"|'([^']*)'|(\S+))\s*$/);
    if (attributeOnlyMatch) {
        text = attributeOnlyMatch[1] || attributeOnlyMatch[2] || attributeOnlyMatch[3] || '';
    }

    const streamTitleMatch = text.match(/StreamTitle='([^']*)'/i);
    if (streamTitleMatch) {
        text = streamTitleMatch[1];
    }

    text = text.replace(/^StreamTitle=/i, '');
    text = text.replace(/;StreamUrl='[^']*';?/ig, '');
    text = text.replace(/;StreamUrl=[^;]*/ig, '');
    text = text.replace(/^['"]/, '').replace(/['"]$/, '');
    text = text.replace(/\+/g, ' ');

    const attributeValuePatterns = [
        /text="([^"]+)"/i,
        /title="([^"]+)"/i,
        /song="([^"]+)"/i,
        /artist="([^"]+)"/i,
        /album="([^"]+)"/i,
        /name="([^"]+)"/i,
        /description="([^"]+)"/i,
        /value="([^"]+)"/i
    ];

    for (const pattern of attributeValuePatterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
            text = match[1];
            break;
        }
    }

    if (/[&][a-z0-9#]+;/i.test(text)) {
        htmlEntityDecoder.innerHTML = text;
        text = htmlEntityDecoder.value;
    }

    text = text.replace(/<[^>]*>/g, ' ');
    text = text.replace(/https?:\/\/\S+/gi, ' ');
    text = text.replace(/www\.[^\s]+/gi, ' ');

    if (/%[0-9A-Fa-f]{2}/.test(text)) {
        try {
            text = decodeURIComponent(text);
        } catch (err) {
            // Ignore decoding errors and use the original value
        }
    }

    text = text.replace(/\s+\w+="[^"]*"/g, '');
    text = text.replace(/\s+\w+='[^']*'/g, '');
    text = text.replace(/\s+\w+=\S+/g, '');

    const streamMarkerIndex = text.search(/;\s*Stream/i);
    if (streamMarkerIndex !== -1) {
        text = text.substring(0, streamMarkerIndex);
    }

    text = text.replace(/[\s\-–—:]+$/, '');
    text = text.replace(/^[\s\-–—:]+/, '');
    text = text.replace(/\s+/g, ' ');

    return text.trim();
}

function collectStationIdentifiers(metadata, icyFields = {}) {
    const identifiers = new Set();
    const simplifiedIdentifiers = new Set();
    const tokenIdentifiers = new Set();
    const candidateValues = [
        metadata.icy_name,
        metadata.station_name,
        metadata.station_callsign,
        metadata.station_id,
        metadata.station,
        metadata.stream_name,
        metadata.stream_description,
        metadata.short_name,
        metadata.display_name,
        metadata.call_sign,
        metadata.callsign,
        metadata.source_name,
        metadata.device_name,
        metadata.icecast_server,
        metadata.icecast_mount,
        metadata.icecast_description,
        metadata.icecast_server_name,
        metadata.icecast_server_description,
        icyFields.name,
        icyFields.station,
        icyFields.server_name,
        icyFields.stream_description
    ];

    candidateValues.forEach(value => {
        const cleaned = cleanMetadataValue(value);
        if (cleaned) {
            const lower = cleaned.toLowerCase();
            identifiers.add(lower);
            const simplified = lower.replace(/[^a-z0-9]/g, '');
            if (simplified) {
                simplifiedIdentifiers.add(simplified);
            }
            lower.split(/[^a-z0-9]+/).filter(Boolean).forEach(token => {
                if (token.length >= 3) {
                    tokenIdentifiers.add(token);
                }
            });
        }
    });

    return {
        primary: identifiers,
        simplified: simplifiedIdentifiers,
        tokens: tokenIdentifiers
    };
}

function isMeaningfulMetadataValue(value, stationIdentifiers = { primary: new Set(), simplified: new Set(), tokens: new Set() }) {
    if (!value) {
        return false;
    }

    const text = value.trim();
    if (!text) {
        return false;
    }

    const lower = text.toLowerCase();

    const simplified = lower.replace(/[^a-z0-9]/g, '');

    if (stationIdentifiers.primary.has(lower) || (simplified && stationIdentifiers.simplified.has(simplified))) {
        return false;
    }

    for (const ident of stationIdentifiers.primary) {
        if (!ident || ident.length < 6) {
            continue;
        }
        if (lower.includes(ident) || ident.includes(lower)) {
            return false;
        }
        const identSimplified = ident.replace(/[^a-z0-9]/g, '');
        if (simplified && identSimplified && (identSimplified.includes(simplified) || simplified.includes(identSimplified))) {
            return false;
        }
    }

    if (stationIdentifiers.tokens.size) {
        const words = lower.split(/[^a-z0-9]+/).filter(Boolean);
        if (words.length) {
            const matches = words.filter(word => stationIdentifiers.tokens.has(word));
            if (matches.length >= 2 || (words.length === 1 && matches.length === 1)) {
                return false;
            }
            const coverage = matches.length / words.length;
            if (coverage >= 0.6) {
                return false;
            }
        }
    }

    const junkPatterns = [
        /^(listen\s+live|click\s+to\s+listen|tune\s+in)$/i,
        /streamtitle/i,
        /streamurl/i,
        /%[0-9a-f]{2}/i,
        /https?:/i,
        /onlineradiobox/i,
        /radio\.net/i,
        /iheart/i,
        /broadcaster/i,
        /digital\s+stream/i,
        /now\s+playing[:\-]?$/i,
        /listen\s*now/i
    ];

    if (junkPatterns.some(pattern => pattern.test(text))) {
        return false;
    }

    if (/^(n\/a|na|none|null|unknown)$/i.test(text)) {
        return false;
    }

    if (!/[a-z]/i.test(text) && !/[0-9]/.test(text)) {
        return false;
    }

    return true;
}

function escapeHtml(text) {
    if (text === null || text === undefined) return '';
    const div = document.createElement('div');
    div.textContent = String(text);
    return div.innerHTML;
}

async function startSource(sourceName) {
    try {
        const response = await fetch(`/api/audio/sources/${encodeURIComponent(sourceName)}/start`, {
            method: 'POST'
        });

        if (!response.ok) {
            const error = await response.json();
            alert(`Failed to start source: ${error.error || 'Unknown error'}`);
            return;
        }

        // Reload sources after a brief delay
        setTimeout(loadAudioSources, 1000);
    } catch (error) {
        console.error('Error starting source:', error);
        alert(`Error starting source: ${error.message}`);
    }
}

async function stopSource(sourceName) {
    try {
        const response = await fetch(`/api/audio/sources/${encodeURIComponent(sourceName)}/stop`, {
            method: 'POST'
        });

        if (!response.ok) {
            const error = await response.json();
            alert(`Failed to stop source: ${error.error || 'Unknown error'}`);
            return;
        }

        // Reload sources
        loadAudioSources();
    } catch (error) {
        console.error('Error stopping source:', error);
        alert(`Error stopping source: ${error.message}`);
    }
}

function updateLevelMetersFromSnapshot(snapshot) {
    if (!snapshot || !Array.isArray(snapshot.live_metrics)) {
        return;
    }

    snapshot.live_metrics.forEach(metric => {
        const safeId = sanitizeId(metric.source_id);
        const peakBar = document.getElementById(`peak-meter-${safeId}`);
        const rmsBar = document.getElementById(`rms-meter-${safeId}`);
        const peakLabel = document.getElementById(`peak-label-${safeId}`);
        const rmsLabel = document.getElementById(`rms-label-${safeId}`);

        if (peakBar) {
            peakBar.style.width = `${calculateFillWidth(metric.peak_level_db)}%`;
            peakBar.style.opacity = metric.source_status === 'running' ? 1 : 0.35;
        }

        if (rmsBar) {
            rmsBar.style.width = `${calculateFillWidth(metric.rms_level_db)}%`;
            rmsBar.style.opacity = metric.source_status === 'running' ? 0.9 : 0.3;
        }

        if (peakLabel) {
            peakLabel.textContent = `Peak: ${formatDbLabel(metric.peak_level_db)}`;
        }
        if (rmsLabel) {
            rmsLabel.textContent = `RMS: ${formatDbLabel(metric.rms_level_db)}`;
        }
    });
}

async function updateLevelMeters() {
    try {
        const response = await fetch('/api/audio/metrics');
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        const data = await response.json();
        updateLevelMetersFromSnapshot(data);
    } catch (error) {
        console.debug('Level meter update skipped:', error);
    }
}

function startLevelPolling() {
    if (levelIntervalHandle) {
        clearInterval(levelIntervalHandle);
    }

    updateLevelMeters();
    levelIntervalHandle = setInterval(updateLevelMeters, 1000);
}

// Load sources on page load
document.addEventListener('DOMContentLoaded', function() {
    loadAudioSources();

    // Auto-refresh every 30 seconds (increased from 5s to reduce interruptions)
    // Only refreshes status/metrics, not the entire player
    setInterval(loadAudioSources, 30000);
});

// Clean up intervals when page unloads
window.addEventListener('beforeunload', function() {
    if (levelIntervalHandle) {
        clearInterval(levelIntervalHandle);
        levelIntervalHandle = null;
    }
});
</script>
{% endblock %}
