{% extends "base.html" %}

{% block title %}Audio Monitoring - EAS Station{% endblock %}

{% block content %}
<div class="row mb-3">
    <div class="col-12">
        <h2><i class="fas fa-headphones"></i> Audio Monitoring</h2>
        <p class="text-muted">Listen to live audio from configured sources</p>
    </div>
</div>

<div class="row mb-3">
    <div class="col-12">
        <div class="card">
            <div class="card-body d-flex flex-wrap gap-3 align-items-center justify-content-between">
                <div>
                    <h5 class="mb-1">Streaming mode</h5>
                    <p class="text-muted small mb-0">
                        Use the built-in HTTPS player when Icecast is blocked or unreliable. Switch to Icecast when available for long-distance listening.
                    </p>
                </div>
                <div class="btn-group" role="group" aria-label="Audio streaming mode">
                    <button type="button" class="btn btn-outline-primary" id="stream-mode-builtin" onclick="setPreferredStreamMode('builtin')">
                        <i class="fas fa-lock"></i> Built-in (HTTPS)
                    </button>
                    <button type="button" class="btn btn-outline-secondary" id="stream-mode-icecast" onclick="setPreferredStreamMode('icecast')">
                        <i class="fas fa-broadcast-tower"></i> Icecast (if available)
                    </button>
                </div>
                <div class="text-muted small" id="stream-mode-status"></div>
            </div>
        </div>
    </div>
</div>

<div class="row mb-3">
    <div class="col-12">
        <div class="alert alert-info">
            <i class="fas fa-info-circle"></i>
            <strong>Live Audio Monitoring:</strong> Audio sources must be running to stream audio. Use the start button if a source is stopped.
            <br>
            <strong>Background Monitoring:</strong> EAS alert detection, waveform visualization, and audio level monitoring run continuously in the background, independent of web playback.
            Even if you pause or stop web playback, the system continues monitoring for alerts 24/7.
            <br>
            <strong>Real-Time Streaming:</strong> The monitor uses a streaming decoder that processes audio samples immediately as they arrive — no buffering, no batching, no delays. Every sample is analyzed in real-time for SAME headers, matching commercial EAS decoder behavior (sub-second detection latency).
        </div>
    </div>
</div>

<!-- EAS Monitor Status Card -->
<div class="row mb-3">
    <div class="col-12">
        <div class="card border-primary">
            <div class="card-header bg-primary text-white">
                <div class="d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="fas fa-satellite-dish"></i> EAS Continuous Monitor
                    </h5>
                    <div id="eas-monitor-status-badge">
                        <span class="badge bg-secondary">Loading...</span>
                    </div>
                </div>
            </div>
            <div class="card-body">
                <div id="eas-monitor-error" class="alert alert-warning d-none">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span id="eas-monitor-error-message"></span>
                </div>

                <!-- Decoder Health -->
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <strong>Decoder Health</strong>
                        <span id="eas-buffer-percentage" class="text-muted">--</span>
                    </div>
                    <div class="progress" style="height: 25px;">
                        <div id="eas-buffer-bar"
                             class="progress-bar progress-bar-striped progress-bar-animated"
                             role="progressbar"
                             style="width: 0%"
                             aria-valuenow="0"
                             aria-valuemin="0"
                             aria-valuemax="100">
                            <span id="eas-buffer-text">0%</span>
                        </div>
                    </div>
                    <small id="eas-buffer-status" class="text-muted d-block mt-1">
                        <i class="fas fa-circle-notch fa-spin"></i> Waiting for data...
                    </small>
                </div>

                <!-- Metrics Grid -->
                <div class="row g-3">
                    <div class="col-md-3 col-sm-6">
                        <div class="metric-item bg-light">
                            <div class="metric-label">Monitor Status</div>
                            <div class="metric-value" id="eas-running-status">--</div>
                        </div>
                    </div>
                    <div class="col-md-3 col-sm-6">
                        <div class="metric-item bg-light">
                            <div class="metric-label">Samples Processed</div>
                            <div class="metric-value" id="eas-scans-count">--</div>
                            <small class="text-muted d-block" style="font-size: 0.7rem;" id="eas-scans-breakdown">--</small>
                        </div>
                    </div>
                    <div class="col-md-3 col-sm-6">
                        <div class="metric-item bg-light">
                            <div class="metric-label">Alerts Detected</div>
                            <div class="metric-value" id="eas-alerts-count">--</div>
                        </div>
                    </div>
                    <div class="col-md-3 col-sm-6">
                        <div class="metric-item bg-light">
                            <div class="metric-label">Decoder Status</div>
                            <div class="metric-value" id="eas-active-scans">--</div>
                        </div>
                    </div>
                </div>

                <!-- Streaming Details -->
                <div class="row g-3 mt-2">
                    <div class="col-md-3 col-sm-6">
                        <small class="text-muted" title="Audio processing rate">Sample Rate:</small>
                        <div><strong id="eas-sample-rate">--</strong></div>
                    </div>
                    <div class="col-md-3 col-sm-6">
                        <small class="text-muted" title="Actual samples processed per second">Processing Rate:</small>
                        <div><strong id="eas-scan-interval">--</strong></div>
                    </div>
                    <div class="col-md-3 col-sm-6">
                        <small class="text-muted" title="Total runtime since start">Runtime:</small>
                        <div><strong id="eas-scan-overlap">--</strong></div>
                    </div>
                    <div class="col-md-3 col-sm-6">
                        <small class="text-muted" title="SAME bytes decoded">Bytes Decoded:</small>
                        <div><strong id="eas-buffer-duration">--</strong></div>
                    </div>
                </div>

                <div class="row g-3 mt-2">
                    <div class="col-md-4 col-sm-6">
                        <small class="text-muted">Decoder Synced:</small>
                        <div><strong id="eas-last-scan">--</strong></div>
                    </div>
                    <div class="col-md-4 col-sm-6">
                        <small class="text-muted">Last Alert:</small>
                        <div><strong id="eas-last-alert">--</strong></div>
                    </div>
                    <div class="col-md-4 col-sm-6">
                        <small class="text-muted">In Message:</small>
                        <div><strong id="eas-scan-warnings">--</strong></div>
                    </div>
                </div>

                <!-- Streaming Performance -->
                <div class="mt-3 pt-3 border-top">
                    <h6 class="mb-3">
                        <i class="fas fa-tachometer-alt"></i> Streaming Performance
                    </h6>
                    
                    <div class="row g-3">
                        <div class="col-md-4 col-sm-6">
                            <div class="metric-item bg-light">
                                <div class="metric-label">Processing Mode</div>
                                <div class="metric-value">
                                    <span id="eas-effective-interval">Streaming</span>
                                    <small id="eas-configured-interval" class="text-muted d-block" style="font-size: 0.7rem;">Zero latency</small>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4 col-sm-6">
                            <div class="metric-item bg-light">
                                <div class="metric-label">Detection Latency</div>
                                <div class="metric-value" id="eas-max-workers">Real-time</div>
                            </div>
                        </div>
                        <div class="col-md-4 col-sm-6">
                            <div class="metric-item bg-light">
                                <div class="metric-label">Architecture</div>
                                <div class="metric-value" id="eas-avg-scan-time">Streaming</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="row g-3 mt-2">
                        <div class="col-12">
                            <small class="text-muted">
                                <i class="fas fa-info-circle"></i>
                                <strong>Decoder Status:</strong>
                                <span id="performance-status">Loading...</span>
                            </small>
                        </div>
                    </div>
                </div>

                <!-- Control Buttons -->
                <div class="mt-3 d-flex gap-2">
                    <button class="btn btn-success btn-sm" id="eas-start-btn" onclick="controlEASMonitor('start')" disabled>
                        <i class="fas fa-play"></i> Start Monitor
                    </button>
                    <button class="btn btn-danger btn-sm" id="eas-stop-btn" onclick="controlEASMonitor('stop')" disabled>
                        <i class="fas fa-stop"></i> Stop Monitor
                    </button>
                    <button class="btn btn-outline-primary btn-sm" onclick="loadEASMonitorStatus()">
                        <i class="fas fa-sync"></i> Refresh
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="audio-sources-container" class="row">
    <div class="col-12 text-center">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="text-muted mt-2">Loading audio sources...</p>
    </div>
</div>

<style>
.audio-source-card {
    border-left: 4px solid #0d6efd;
    transition: all 0.3s ease;
}

.audio-source-card.status-running {
    border-left-color: #28a745;
}

.audio-source-card.status-stopped {
    border-left-color: #6c757d;
}

.audio-source-card.status-error {
    border-left-color: #dc3545;
}

.audio-source-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.audio-player-container {
    background: #f8f9fa;
    padding: 1rem;
    border-radius: 8px;
    margin-top: 1rem;
}

.audio-player-container audio {
    width: 100%;
    height: 54px;
}

.status-badge {
    font-size: 0.875rem;
    padding: 0.375rem 0.75rem;
}

.metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 0.75rem;
    margin-top: 1rem;
}

.metric-item {
    background: #e9ecef;
    padding: 0.75rem;
    border-radius: 6px;
    text-align: center;
}

.metric-label {
    font-size: 0.75rem;
    color: #6c757d;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.metric-value {
    font-size: 1.25rem;
    font-weight: bold;
    color: #212529;
}

.now-playing-title {
    font-size: 1rem;
    font-weight: 600;
    line-height: 1.35;
}

.now-playing-artist {
    font-size: 0.95rem;
    color: #495057;
}

.now-playing-meta {
    font-size: 0.85rem;
    color: #6c757d;
}

.level-meter {
    height: 20px;
    background: linear-gradient(to right, #28a745, #ffc107, #dc3545);
    border-radius: 10px;
    position: relative;
    overflow: hidden;
}

.level-indicator {
    position: absolute;
    left: 50%;
    top: 0;
    bottom: 0;
    width: 2px;
    background: #000;
    transform: translateX(-50%);
}

.vu-meter {
    background: #101010;
    border-radius: 10px;
    padding: 0.75rem;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.04);
}

.vu-track {
    position: relative;
    height: 14px;
    border-radius: 7px;
    background: linear-gradient(90deg, #1e7e34, #ffc107 70%, #dc3545);
    overflow: hidden;
}

.vu-fill {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 0%;
    background: rgba(255, 255, 255, 0.75);
    box-shadow: 0 0 6px rgba(255,255,255,0.4);
    transition: width 0.15s ease-out, opacity 0.15s ease-out;
}

.vu-fill.rms {
    background: rgba(0, 198, 255, 0.75);
    box-shadow: 0 0 6px rgba(0,198,255,0.4);
}

.vu-labels {
    font-size: 0.85rem;
    color: #adb5bd;
}

.vu-labels span {
    font-variant-numeric: tabular-nums;
}
</style>

<script src="https://cdn.socket.io/4.5.4/socket.io.min.js" crossorigin="anonymous"></script>
<script>
let audioSources = [];
let audioMonitoringSocket = null;
const STREAM_MODE_KEY = 'audioMonitorStreamMode';
const htmlEntityDecoder = document.createElement('textarea');

// EAS Monitor warmup configuration
const EAS_WARMUP_DURATION_SECONDS = 10; // Show "warming up" only during first 10 seconds

// VU meter state tracking for smoothing and peak hold
const vuMeterState = new Map(); // sourceId -> { lastPeak, lastRms, peakHold, peakHoldTime }

// VU meter behavior constants
const PEAK_HOLD_TIME_MS = 1500; // Hold peak for 1.5 seconds
const PEAK_ATTACK_SMOOTHING = 0.7; // Attack: high alpha = quick response to increases (0-1)
const PEAK_RELEASE_SMOOTHING = 0.2; // Release: low alpha = slow response to decreases (0-1)
const RMS_SMOOTHING = 0.3; // RMS uses moderate smoothing (0-1)

function getPreferredStreamMode() {
    const stored = (localStorage.getItem(STREAM_MODE_KEY) || '').toLowerCase();
    return stored === 'icecast' ? 'icecast' : 'builtin';
}

function setPreferredStreamMode(mode) {
    const normalized = mode === 'icecast' ? 'icecast' : 'builtin';
    localStorage.setItem(STREAM_MODE_KEY, normalized);
    renderStreamModeControls();
    // Re-evaluate current players using the newly selected mode
    initializeAudioPlayers();
}

function renderStreamModeControls() {
    const mode = getPreferredStreamMode();
    const builtInBtn = document.getElementById('stream-mode-builtin');
    const icecastBtn = document.getElementById('stream-mode-icecast');
    const statusEl = document.getElementById('stream-mode-status');

    if (builtInBtn && icecastBtn) {
        builtInBtn.classList.toggle('btn-primary', mode === 'builtin');
        builtInBtn.classList.toggle('btn-outline-primary', mode !== 'builtin');
        icecastBtn.classList.toggle('btn-secondary', mode === 'icecast');
        icecastBtn.classList.toggle('btn-outline-secondary', mode !== 'icecast');
    }

    if (statusEl) {
        statusEl.textContent = mode === 'icecast'
            ? 'Icecast will be used when reachable; HTTPS-only pages still fall back automatically.'
            : 'Built-in HTTPS stream preferred. Icecast will only be used if you switch modes.';
    }
}

// Fetch audio sources from API
async function loadAudioSources(fullRender = true) {
    try {
        const response = await fetch('/api/audio/sources');
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        audioSources = data.sources || [];
        renderAudioSources(fullRender);
    } catch (error) {
        console.error('Failed to load audio sources:', error);
        if (fullRender) {
            document.getElementById('audio-sources-container').innerHTML = `
                <div class="col-12">
                    <div class="alert alert-danger">
                        <strong>Error loading audio sources:</strong> ${error.message}
                        <div class="small text-muted mt-1">Check that you are signed in and the audio API is reachable.</div>
                    </div>
                </div>
            `;
        }
    }
}

function updateAudioSourcesFromRealtime(sources) {
    if (!Array.isArray(sources) || sources.length === 0) {
        return;
    }

    const updatesByName = new Map(
        sources
            .map(src => [src.name || src.source_id || src.id, src])
            .filter(entry => entry[0])
    );

    audioSources = audioSources.map(source => {
        const update = updatesByName.get(source.name);
        if (update) {
            const status = update.status || update.source_status || source.status;
            return { ...source, status };
        }
        return source;
    });

    updatesByName.forEach((update, name) => {
        if (!name) return;
        const card = document.querySelector(`[data-source-card="${CSS.escape(name)}"]`);
        if (!card) return;

        const status = (update.status || update.source_status || 'stopped').toLowerCase();
        card.className = `card audio-source-card status-${status}`;

        const badge = card.querySelector('.status-badge');
        if (badge) {
            badge.className = `badge status-badge bg-${getStatusColor(status)}`;
            badge.textContent = status.toUpperCase();
        }
    });
}

function updateSourcePlayer(source) {
    // Dynamically update audio player when stream state changes
    const audioEl = document.getElementById(`audio-${source.name}`);
    if (!audioEl || source.status !== 'running') {
        return;
    }

    // Check if Icecast URL availability has changed
    const currentIcecastUrl = audioEl.dataset.icecastUrl || '';
    const newIcecastUrl = source.icecast_url || '';
    
    if (currentIcecastUrl !== newIcecastUrl) {
        // Icecast URL changed - update the data attribute
        audioEl.dataset.icecastUrl = newIcecastUrl;
        
        // Determine if we should switch sources
        const wasPlaying = !audioEl.paused && audioEl.currentTime > 0;
        const preferIcecast = shouldUseIcecastStream(audioEl);
        const currentStreamType = audioEl.dataset.streamType || '';
        
        // Switch if preference changed
        if (preferIcecast && currentStreamType !== 'icecast' && newIcecastUrl) {
            console.debug(`Switching ${source.name} to Icecast stream`);
            audioEl.dataset.streamType = 'icecast';
            audioEl.src = newIcecastUrl;
            audioEl.dataset.suppressPauseMessage = '1';
            audioEl.load();
            
            if (wasPlaying) {
                audioEl.play().catch(err => {
                    console.debug(`Could not resume playback after switch to Icecast:`, err.message);
                });
            }
        } else if (!preferIcecast && currentStreamType === 'icecast') {
            console.debug(`Switching ${source.name} to proxy stream`);
            switchToProxyStream(audioEl, source.name, {
                autoplay: wasPlaying,
                reason: 'Icecast stream no longer available',
                notify: true
            });
        }
    }
}

function updateMetricsOnly() {
    // Update metrics for each source without touching audio players
    audioSources.forEach(source => {
        const safeId = sanitizeId(source.name);

        // Update status badge
        const card = document.querySelector(`[data-source-card="${source.name}"]`);
        if (card) {
            card.className = `card audio-source-card status-${source.status}`;
        }

        // Update metrics if source is running
        if (source.status === 'running' && source.metrics) {
            // Update level meters
            const peakMeter = document.getElementById(`peak-meter-${safeId}`);
            const rmsMeter = document.getElementById(`rms-meter-${safeId}`);
            const peakLabel = document.getElementById(`peak-label-${safeId}`);
            const rmsLabel = document.getElementById(`rms-label-${safeId}`);

            if (peakMeter) {
                peakMeter.style.width = `${calculateFillWidth(source.metrics.peak_level_db)}%`;
            }
            if (rmsMeter) {
                rmsMeter.style.width = `${calculateFillWidth(source.metrics.rms_level_db)}%`;
            }
            if (peakLabel) {
                peakLabel.textContent = `Peak: ${formatDbLabel(source.metrics.peak_level_db)}`;
            }
            if (rmsLabel) {
                rmsLabel.textContent = `RMS: ${formatDbLabel(source.metrics.rms_level_db)}`;
            }
            
            // Check if player needs to be updated due to stream state changes
            updateSourcePlayer(source);
        }
    });
}

function renderAudioSources(fullRender = true) {
    const container = document.getElementById('audio-sources-container');

    if (audioSources.length === 0) {
        container.innerHTML = `
            <div class="col-12">
                <div class="alert alert-warning">
                    <i class="fas fa-exclamation-triangle"></i>
                    No audio sources configured. Please configure audio sources in the Audio Settings page.
                </div>
            </div>
        `;
        return;
    }

    // If not doing full render, just update metrics without touching players
    if (!fullRender) {
        updateMetricsOnly();
        return;
    }

    // Save playing state of audio players before re-render
    const playingStates = {};
    const currentTimes = {};
    audioSources.forEach(source => {
        const audioEl = document.getElementById(`audio-${source.name}`);
        if (audioEl) {
            playingStates[source.name] = !audioEl.paused;
            currentTimes[source.name] = audioEl.currentTime;
        }
    });

    container.innerHTML = audioSources.map(source => {
        const safeId = sanitizeId(source.name);
        const peakValue = source.metrics?.peak_level_db;
        const rmsValue = source.metrics?.rms_level_db;

        return `
        <div class="col-lg-6 col-xl-4 mb-3">
            <div class="card audio-source-card status-${source.status}" data-source-card="${escapeHtml(source.name)}">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">
                            <i class="fas fa-${getSourceIcon(source.type)}"></i>
                            ${escapeHtml(source.name)}
                        </h5>
                        <div>
                            <span class="badge status-badge bg-${getStatusColor(source.status)}">
                                ${source.status.toUpperCase()}
                            </span>
                            ${source.status === 'running' ? `
                                <span class="badge bg-info ms-1" title="Background monitoring (EAS detection, waveforms, audio levels) is active">
                                    <i class="fas fa-eye"></i> Monitoring
                                </span>
                            ` : ''}
                        </div>
                    </div>
                    <small class="text-muted">${escapeHtml(source.type.toUpperCase())} Source</small>
                </div>
                <div class="card-body">
                    ${source.description ? `<p class="text-muted">${escapeHtml(source.description)}</p>` : ''}

                    <!-- Live level meter -->
                    <div class="vu-meter" aria-live="polite">
                        <div class="d-flex justify-content-between vu-labels mb-2">
                            <span id="peak-label-${safeId}">Peak: ${formatDbLabel(peakValue)}</span>
                            <span id="rms-label-${safeId}">RMS: ${formatDbLabel(rmsValue)}</span>
                        </div>
                        <div class="vu-track" role="presentation">
                            <div class="vu-fill" id="peak-meter-${safeId}" style="width: ${calculateFillWidth(peakValue)}%"></div>
                            <div class="vu-fill rms" id="rms-meter-${safeId}" style="width: ${calculateFillWidth(rmsValue)}%"></div>
                        </div>
                    </div>

                    <!-- Audio Player -->
                    <div class="audio-player-container" id="player-container-${source.name}">
                        ${source.status === 'running' ? `
                            <audio
                                controls
                                id="audio-${source.name}"
                                preload="none"
                                data-source-name="${escapeHtml(source.name)}"
                                data-icecast-url="${source.icecast_url ? escapeHtml(source.icecast_url) : ''}"
                                data-proxy-url="/api/audio/stream/${encodeURIComponent(source.name)}"
                                data-initial-stream-type="${source.icecast_url ? 'icecast' : 'flask-proxy'}">
                                Your browser does not support the audio element.
                            </audio>
                            <div class="audio-player-status small mt-2 text-muted" id="player-status-${source.name}"></div>
                            ${source.icecast_url ? `
                                <small class="d-block mt-1 text-muted">
                                    <i class="fas fa-broadcast-tower"></i> Icecast streaming available
                                    ${source.streaming && source.streaming.icecast ? `
                                        ${typeof source.streaming.icecast.bitrate_kbps === 'number' ? ` • ${Number(source.streaming.icecast.bitrate_kbps).toFixed(1)} kbps` : ''}
                                        ${typeof source.streaming.icecast.uptime_seconds === 'number' ? ` • <i class="fas fa-clock"></i> Uptime ${Math.floor(source.streaming.icecast.uptime_seconds / 60)}m` : ''}
                                    ` : ''}
                                    <span class="d-block small mt-1">
                                        <i class="fas fa-info-circle"></i> If Icecast is not HTTPS, the UI will use a secure proxied player instead to avoid mixed-content blocking.
                                    </span>
                                </small>
                            ` : `
                                <small class="text-muted d-block mt-1">
                                    <i class="fas fa-info-circle"></i> Basic Streaming Mode
                                    <span class="d-block small text-muted mt-1">A secure built-in player is used automatically on HTTPS deployments.</span>
                                    <a href="/settings/audio#icecast" class="d-inline-flex align-items-center gap-1 text-primary mt-1">
                                        <i class="fas fa-arrow-up-right-from-square"></i>
                                        <span>Enable Icecast for professional quality</span>
                                    </a>
                                </small>
                            `}
                        ` : `
                            <div class="alert alert-secondary mb-0">
                                <i class="fas fa-pause-circle"></i>
                                Audio source is ${source.status}. ${source.error_message ? `Error: ${escapeHtml(source.error_message)}` : 'Start the source to listen.'}
                            </div>
                        `}
                    </div>

                    <!-- Metrics -->
                    ${source.status === 'running' && source.metrics ? `
                        <div class="metrics-grid">
                            <div class="metric-item">
                                <div class="metric-label">Peak</div>
                                <div class="metric-value">${source.metrics.peak_level_db.toFixed(1)} dB</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-label">RMS</div>
                                <div class="metric-value">${source.metrics.rms_level_db.toFixed(1)} dB</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-label">Sample Rate</div>
                                <div class="metric-value">${(source.metrics.sample_rate / 1000).toFixed(1)} kHz</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-label">Channels</div>
                                <div class="metric-value">${source.metrics.channels}</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-label">Buffer</div>
                                <div class="metric-value">${(source.metrics.buffer_utilization * 100).toFixed(0)}%</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-label">Frames</div>
                                <div class="metric-value">${(source.metrics.frames_captured || 0).toLocaleString()}</div>
                            </div>
                        </div>

                        <!-- Buffer Utilization Indicator -->
                        <div class="mt-2">
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <small class="text-muted">Buffer Utilization</small>
                                <small class="text-muted">${(source.metrics.buffer_utilization * 100).toFixed(1)}%</small>
                            </div>
                            <div class="progress" style="height: 6px;">
                                <div class="progress-bar ${source.metrics.buffer_utilization > 0.95 ? 'bg-danger' : source.metrics.buffer_utilization > 0.8 ? 'bg-warning' : 'bg-success'}"
                                     role="progressbar"
                                     style="width: ${(source.metrics.buffer_utilization * 100).toFixed(1)}%"
                                     aria-valuenow="${(source.metrics.buffer_utilization * 100).toFixed(1)}"
                                     aria-valuemin="0"
                                     aria-valuemax="100"></div>
                            </div>
                            <small class="text-muted">
                                ${source.metrics.buffer_utilization < 0.01 ? '⚠️ No data flowing' :
                                  source.metrics.buffer_utilization > 0.95 ? '⚠️ Buffer nearly full' :
                                  '✓ Data flowing normally'}
                            </small>
                        </div>

                        <!-- Now Playing (if available) -->
                        ${(() => {
                            const nowPlaying = normalizeNowPlayingMetadata(source.metrics.metadata);
                            if (!nowPlaying) {
                                return '';
                            }

                            const { artworkUrl, title, artist, album, length } = nowPlaying;

                            return `
                                <div class="mt-3">
                                    <h6 class="text-muted mb-2"><i class="fas fa-music"></i> Now Playing</h6>
                                    <div class="card bg-light border-0">
                                        <div class="card-body p-3">
                                            <div class="row align-items-center">
                                                ${artworkUrl ? `
                                                    <div class="col-auto">
                                                        <img src="${escapeHtml(artworkUrl)}"
                                                             alt="Album Art"
                                                             class="img-thumbnail"
                                                             style="width: 100px; height: 100px; object-fit: cover;"
                                                             onerror="this.style.display='none'">
                                                    </div>
                                                ` : ''}
                                                <div class="col">
                                                    ${title ? `<div class="now-playing-title text-break">${escapeHtml(title)}</div>` : ''}
                                                    ${artist ? `<div class="now-playing-artist text-break">${escapeHtml(artist)}</div>` : ''}
                                                    ${album ? `<div class="now-playing-meta text-break"><i class="fas fa-compact-disc"></i> ${escapeHtml(album)}</div>` : ''}
                                                    ${length ? `<div class="now-playing-meta text-break"><i class="fas fa-clock"></i> ${escapeHtml(length)}</div>` : ''}
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        })()}

                        <!-- Stream Metadata (if available) -->
                                    ${source.metrics.metadata ? `
                                        <div class="mt-3">
                                            <h6 class="text-muted mb-2"><i class="fas fa-info-circle"></i> Stream Information</h6>
                                            <div class="small">
                                                ${source.metrics.metadata.receiver_display_name ? `
                                                    <div class="d-flex justify-content-between mb-1">
                                                        <span class="text-muted">Receiver:</span>
                                                        <span class="fw-bold">
                                                            ${escapeHtml(source.metrics.metadata.receiver_display_name)}
                                                            ${source.metrics.metadata.receiver_identifier ? `
                                                                <span class="text-muted small ms-2">${escapeHtml(source.metrics.metadata.receiver_identifier)}</span>
                                                            ` : ''}
                                                        </span>
                                                    </div>
                                                ` : ''}
                                                ${source.metrics.metadata.receiver_frequency_display ? `
                                                    <div class="d-flex justify-content-between mb-1">
                                                        <span class="text-muted">Frequency:</span>
                                                        <span>${escapeHtml(source.metrics.metadata.receiver_frequency_display)}</span>
                                                    </div>
                                                ` : ''}
                                                ${source.metrics.metadata.receiver_modulation ? `
                                                    <div class="d-flex justify-content-between mb-1">
                                                        <span class="text-muted">Mode:</span>
                                                        <span class="text-uppercase">${escapeHtml(source.metrics.metadata.receiver_modulation)}</span>
                                                    </div>
                                                ` : ''}
                                                ${source.metrics.metadata.receiver_driver ? `
                                                    <div class="d-flex justify-content-between mb-1">
                                                        <span class="text-muted">Driver:</span>
                                                        <span class="font-monospace small">${escapeHtml(source.metrics.metadata.receiver_driver)}</span>
                                                    </div>
                                                ` : ''}
                                                ${source.metrics.metadata.codec ? `
                                                    <div class="d-flex justify-content-between mb-1">
                                                        <span class="text-muted">Codec:</span>
                                                        <span class="fw-bold text-uppercase">
                                                            ${escapeHtml(source.metrics.metadata.codec)}
                                                ${source.metrics.metadata.codec_version ? `
                                                    <span class="badge bg-secondary text-white small ms-1">${escapeHtml(source.metrics.metadata.codec_version)}</span>
                                                ` : ''}
                                            </span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.bitrate_kbps ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">Bitrate:</span>
                                            <span class="fw-bold">
                                                ${source.metrics.metadata.bitrate_kbps} kbps
                                                ${source.metrics.metadata.is_vbr ? `
                                                    <span class="badge bg-info text-white small ms-1">VBR</span>
                                                ` : ''}
                                            </span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.icy_name ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">Station:</span>
                                            <span class="fw-bold">${escapeHtml(source.metrics.metadata.icy_name)}</span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.icy_genre ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">Genre:</span>
                                            <span>${escapeHtml(source.metrics.metadata.icy_genre)}</span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.stream_url ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">URL:</span>
                                            <span class="font-monospace small text-break">${escapeHtml(source.metrics.metadata.stream_url)}</span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.icecast_stream_url && source.metrics.metadata.icecast_stream_url !== source.metrics.metadata.stream_url ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">Icecast URL:</span>
                                            <span class="font-monospace small text-break">${escapeHtml(source.metrics.metadata.icecast_stream_url)}</span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.icecast_server ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">Icecast Server:</span>
                                            <span class="font-monospace small text-break">${escapeHtml(source.metrics.metadata.icecast_server)}${source.metrics.metadata.icecast_port ? `:${source.metrics.metadata.icecast_port}` : ''}</span>
                                        </div>
                                    ` : ''}
                                    ${source.metrics.metadata.icecast_mount ? `
                                        <div class="d-flex justify-content-between mb-1">
                                            <span class="text-muted">Mount:</span>
                                            <span class="font-monospace small text-break">${escapeHtml(source.metrics.metadata.icecast_mount)}</span>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        ` : ''}
                    ` : ''}

                    <!-- Control Buttons -->
                    <div class="mt-3 d-flex gap-2">
                        ${source.status !== 'running' ? `
                            <button class="btn btn-success btn-sm" onclick="startSource('${source.name}')">
                                <i class="fas fa-play"></i> Start
                            </button>
                        ` : `
                            <button class="btn btn-danger btn-sm" onclick="stopSource('${source.name}')">
                                <i class="fas fa-stop"></i> Stop
                            </button>
                        `}
                        <button class="btn btn-outline-primary btn-sm" onclick="loadAudioSources()">
                            <i class="fas fa-sync"></i> Refresh
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;}).join('');

    initializeAudioPlayers(playingStates, currentTimes);
}

function sanitizeId(text) {
    return (text || '').toString().replace(/[^a-zA-Z0-9_-]/g, '-');
}

function formatDbLabel(value) {
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return '-- dBFS';
    }
    return `${value.toFixed(1)} dBFS`;
}

function calculateFillWidth(value) {
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return 0;
    }
    // Professional VU meter mapping: -60 dBFS to 0 dBFS
    // Use logarithmic-like scaling for better visual response
    const MIN_DB = -60;
    const MAX_DB = 0;
    const clamped = Math.max(MIN_DB, Math.min(MAX_DB, value));
    
    // Convert to 0-1 range
    const normalized = (clamped - MIN_DB) / (MAX_DB - MIN_DB);
    
    // Apply slight curve for better visual response at lower levels
    // This makes the meter more responsive in the typical operating range (-40 to -10 dBFS)
    const curved = Math.pow(normalized, 0.8);
    
    return curved * 100;
}

function initializeAudioPlayers(playingStates = {}, currentTimes = {}) {
    audioSources.forEach(source => {
        if (source.status !== 'running') {
            setPlayerStatus(source.name, '', 'muted');
            return;
        }

        const audioEl = document.getElementById(`audio-${source.name}`);
        if (!audioEl) {
            return;
        }

        // Check if this is a fresh initialization (no handlers bound yet)
        const isNewPlayer = audioEl.dataset.handlersBound !== '1';

        audioEl.dataset.sourceName = source.name;
        if (!audioEl.dataset.proxyUrl) {
            audioEl.dataset.proxyUrl = `/api/audio/stream/${encodeURIComponent(source.name)}`;
        }

        bindAudioPlayerEvents(audioEl);

        // If player was already initialized and playing, don't interrupt it
        if (!isNewPlayer && !audioEl.paused && audioEl.currentTime > 0) {
            console.debug(`Preserving active playback for ${source.name}`);
            return;
        }

        const wasPlaying = Boolean(playingStates[source.name]);
        const preferIcecast = shouldUseIcecastStream(audioEl);

        if (preferIcecast) {
            const icecastUrl = audioEl.dataset.icecastUrl;
            audioEl.dataset.streamType = 'icecast';

            if (icecastUrl && audioEl.src !== icecastUrl) {
                audioEl.src = icecastUrl;
                audioEl.dataset.suppressPauseMessage = '1';
                audioEl.load();
            }

            setPlayerStatus(source.name, 'Ready. Press play to listen via Icecast.', 'muted');

            if (wasPlaying) {
                const resumeTime = currentTimes[source.name] || 0;
                if (resumeTime > 0 && !Number.isNaN(resumeTime)) {
                    try {
                        audioEl.currentTime = resumeTime;
                    } catch (err) {
                        console.debug(`Unable to restore playback position for ${source.name}:`, err.message);
                    }
                }

                audioEl.play().catch(err => {
                    console.debug(`Could not auto-resume playback for ${source.name}:`, err.message);
                });
            }

            return;
        }

        const fallbackReason = audioEl.dataset.icecastUrl ? 'Icecast stream is unavailable on secure connections.' : '';

        switchToProxyStream(audioEl, source.name, {
            autoplay: wasPlaying,
            reason: fallbackReason,
            notify: !wasPlaying
        });
    });
}

function bindAudioPlayerEvents(audioEl) {
    if (audioEl.dataset.handlersBound === '1') {
        return;
    }

    const sourceName = audioEl.dataset.sourceName || '';

    audioEl.addEventListener('loadstart', () => {
        clearStreamRecoveryTimer(audioEl);
        setPlayerStatus(sourceName, 'Connecting to stream…', 'info');
    });

    audioEl.addEventListener('playing', () => {
        audioEl.dataset.fallbackRetries = '0';
        clearStreamRecoveryTimer(audioEl);
        setPlayerStatus(sourceName, `${labelForStreamType(audioEl.dataset.streamType)} playing.`, 'success');
    });

    audioEl.addEventListener('waiting', () => {
        // Only show buffering status, don't trigger recovery immediately
        // The 'stalled' event will handle actual recovery if needed
        setPlayerStatus(sourceName, 'Buffering…', 'info');
    });

    audioEl.addEventListener('stalled', () => {
        // Only trigger recovery on actual stall, not during normal buffering
        setPlayerStatus(sourceName, 'Stream stalled – will retry if not recovered…', 'warning');
        scheduleStreamRecovery(audioEl, sourceName);
    });

    audioEl.addEventListener('pause', () => {
        if (!audioEl.dataset.suppressPauseMessage) {
            setPlayerStatus(sourceName, 'Playback paused.', 'muted');
        }
        audioEl.dataset.suppressPauseMessage = '';
        clearStreamRecoveryTimer(audioEl);
    });

    audioEl.addEventListener('ended', () => {
        setPlayerStatus(sourceName, 'Stream ended.', 'muted');
    });

    audioEl.addEventListener('error', onAudioPlaybackError);

    audioEl.dataset.handlersBound = '1';
}

function shouldUseIcecastStream(audioEl) {
    const icecastUrl = audioEl.dataset.icecastUrl;
    if (!icecastUrl) {
        return false;
    }

    if (getPreferredStreamMode() !== 'icecast') {
        return false;
    }

    if (window.location.protocol === 'https:' && /^http:\/\//i.test(icecastUrl)) {
        return false;
    }

    return true;
}

function switchToProxyStream(audioEl, sourceName, options = {}) {
    const { autoplay = false, reason = '', notify = true } = options;
    const proxyUrl = audioEl.dataset.proxyUrl || `/api/audio/stream/${encodeURIComponent(sourceName)}`;

    audioEl.dataset.streamType = 'flask-proxy';
    audioEl.dataset.fallbackActive = audioEl.dataset.icecastUrl ? '1' : audioEl.dataset.fallbackActive;

    const finalUrl = appendCacheBuster(proxyUrl);
    if (audioEl.src !== finalUrl) {
        audioEl.src = finalUrl;
    }
    audioEl.dataset.suppressPauseMessage = '1';
    audioEl.load();

    if (notify) {
        if (audioEl.dataset.icecastUrl) {
            const baseMessage = 'Using secure fallback stream.';
            const message = reason ? `${reason} ${baseMessage}`.trim() : baseMessage;
            setPlayerStatus(sourceName, message, reason ? 'warning' : 'info');
        } else {
            setPlayerStatus(sourceName, 'Ready. Press play to listen.', 'muted');
        }
    }

    if (autoplay) {
        const playPromise = audioEl.play();
        if (playPromise && typeof playPromise.then === 'function') {
            playPromise.then(() => {
                setPlayerStatus(sourceName, `${labelForStreamType(audioEl.dataset.streamType)} playing.`, 'success');
            }).catch(err => {
                console.debug(`Autoplay blocked for ${sourceName}:`, err.message);
                setPlayerStatus(sourceName, audioEl.dataset.icecastUrl
                    ? 'Fallback stream ready. Press play to start listening.'
                    : 'Ready. Press play to listen.',
                    audioEl.dataset.icecastUrl ? 'warning' : 'muted');
            });
        }
    }
}

function appendCacheBuster(url) {
    const separator = url.includes('?') ? '&' : '?';
    return `${url}${separator}ts=${Date.now()}`;
}

function clearStreamRecoveryTimer(audioEl) {
    const timerId = audioEl.dataset.stallTimerId ? parseInt(audioEl.dataset.stallTimerId, 10) : null;
    if (timerId) {
        clearTimeout(timerId);
    }
    audioEl.dataset.stallTimerId = '';
}

function scheduleStreamRecovery(audioEl, sourceName) {
    clearStreamRecoveryTimer(audioEl);

    const streamType = audioEl.dataset.streamType || audioEl.dataset.initialStreamType || 'unknown';
    const wasPlaying = !audioEl.paused;
    // Use longer timeouts to allow network/server time to recover naturally
    // These values prevent aggressive reconnection loops that worsen the problem
    const timeoutMs = streamType === 'icecast' ? 15000 : 12000;

    const timerId = window.setTimeout(() => {
        audioEl.dataset.stallTimerId = '';

        const currentType = audioEl.dataset.streamType || audioEl.dataset.initialStreamType || 'unknown';
        if (currentType !== streamType) {
            return;
        }

        if (currentType === 'icecast') {
            const reason = 'Icecast stream stalled or unreachable. Switching to secure fallback.';
            switchToProxyStream(audioEl, sourceName, { autoplay: wasPlaying, reason });
            return;
        }

        if (currentType === 'flask-proxy') {
            setPlayerStatus(sourceName, 'Reconnecting to secure stream…', 'warning');
            switchToProxyStream(audioEl, sourceName, { autoplay: wasPlaying, notify: false });
        }
    }, timeoutMs);

    audioEl.dataset.stallTimerId = String(timerId);
}

function setPlayerStatus(sourceName, message, level = 'muted') {
    const statusEl = document.getElementById(`player-status-${sourceName}`);
    if (!statusEl) {
        return;
    }

    const levelClasses = {
        muted: 'text-muted',
        info: 'text-info',
        success: 'text-success',
        warning: 'text-warning',
        danger: 'text-danger'
    };

    const baseClass = 'audio-player-status small mt-2';
    const levelClass = levelClasses[level] || 'text-muted';

    statusEl.className = `${baseClass} ${levelClass}`;
    statusEl.textContent = message || '';
}

function labelForStreamType(streamType) {
    switch (streamType) {
        case 'icecast':
            return 'Icecast stream';
        case 'flask-proxy':
            return 'Secure built-in stream';
        default:
            return 'Audio stream';
    }
}

function onAudioPlaybackError(event) {
    const audioEl = event.currentTarget;
    const sourceName = audioEl.dataset.sourceName || 'unknown';
    const streamType = audioEl.dataset.streamType || audioEl.dataset.initialStreamType || 'unknown';
    const error = audioEl.error;

    console.warn(`Audio playback error for ${sourceName} (${streamType})`, error);

    // Debounce: Don't retry if we recently had an error (increased to 10 seconds)
    // This prevents rapid reconnection loops that can overwhelm the server
    const lastErrorTime = parseInt(audioEl.dataset.lastErrorTime || '0', 10);
    const now = Date.now();
    if (now - lastErrorTime < 10000) {
        console.debug(`Debouncing error recovery for ${sourceName} (last error was ${(now - lastErrorTime) / 1000}s ago)`);
        return;
    }
    audioEl.dataset.lastErrorTime = String(now);

    if (streamType === 'icecast') {
        const wasPlaying = !audioEl.paused;
        setPlayerStatus(sourceName, 'Icecast stream failed. Switching to secure fallback…', 'warning');
        switchToProxyStream(audioEl, sourceName, {
            autoplay: wasPlaying,
            notify: false
        });
        return;
    }

    if (streamType === 'flask-proxy') {
        const retries = parseInt(audioEl.dataset.fallbackRetries || '0', 10);

        if (retries < 3) {  // Allow 3 retries with exponential backoff
            audioEl.dataset.fallbackRetries = String(retries + 1);
            const wasPlaying = !audioEl.paused;
            setPlayerStatus(sourceName, `Reconnecting to secure stream (attempt ${retries + 1}/3)…`, 'warning');

            // Use exponential backoff: 3s, 6s, 12s
            const backoffMs = 3000 * Math.pow(2, retries);
            setTimeout(() => {
                switchToProxyStream(audioEl, sourceName, {
                    autoplay: wasPlaying,
                    notify: false
                });
            }, backoffMs);

            return;
        }

        setPlayerStatus(sourceName, 'Unable to connect to audio stream. Please refresh the page or check the source.', 'danger');
    }
}

function getSourceIcon(type) {
    const icons = {
        'sdr': 'satellite-dish',
        'alsa': 'volume-up',
        'pulse': 'volume-up',
        'file': 'file-audio',
        'stream': 'broadcast-tower'
    };
    return icons[type] || 'question';
}

function getStatusColor(status) {
    const colors = {
        'running': 'success',
        'stopped': 'secondary',
        'starting': 'warning',
        'error': 'danger',
        'disconnected': 'warning'
    };
    return colors[status] || 'secondary';
}

function normalizeNowPlayingMetadata(metadata) {
    if (!metadata) {
        return null;
    }

    const icyFields = metadata.icy && metadata.icy.fields ? metadata.icy.fields : {};
    const streamTitleInfo = parseStreamTitle(icyFields.text);

    const artworkUrl = sanitizeArtworkUrl(
        metadata.artwork_url
        || (metadata.now_playing && metadata.now_playing.artwork_url)
        || (icyFields && icyFields.amgArtworkURL)
        || (icyFields && icyFields.artworkURL)
    );

    const stationIdentifiers = collectStationIdentifiers(metadata, icyFields);

    let title = cleanMetadataValue(
        (metadata.now_playing && metadata.now_playing.title)
        || metadata.song_title
        || metadata.title
        || streamTitleInfo.title
        || streamTitleInfo.text
    );

    let artist = cleanMetadataValue(
        (metadata.now_playing && metadata.now_playing.artist)
        || metadata.artist
        || icyFields.artist
        || streamTitleInfo.artist
    );

    let album = cleanMetadataValue(metadata.album || icyFields.album);
    let length = cleanMetadataValue(metadata.length || icyFields.length || icyFields.duration);

    if (!isMeaningfulMetadataValue(title, stationIdentifiers)) {
        title = '';
    }

    if (!isMeaningfulMetadataValue(artist, stationIdentifiers)) {
        artist = '';
    }

    if (!isMeaningfulMetadataValue(album, stationIdentifiers)) {
        album = '';
    }

    if (title && artist) {
        const titleLower = title.toLowerCase();
        const artistLower = artist.toLowerCase();

        if (titleLower === artistLower) {
            artist = '';
        } else if (titleLower.startsWith(`${artistLower} - `)) {
            title = title.substring(artist.length + 3).trim();
        }
    }

    if (album && title && album.toLowerCase() === title.toLowerCase()) {
        album = '';
    }

    if (length && /^(0|0:00)$/.test(length.trim())) {
        length = '';
    }

    if (!artworkUrl && !title && !artist && !album && !length) {
        return null;
    }

    return { artworkUrl, title, artist, album, length };
}

function sanitizeArtworkUrl(value) {
    if (value === null || value === undefined) {
        return '';
    }

    const text = String(value).trim();
    if (!text) {
        return '';
    }

    const lower = text.toLowerCase();
    const banned = new Set(['null', 'none', 'n/a', 'na', 'undefined', 'about:blank']);
    if (banned.has(lower)) {
        return '';
    }

    const isHttp = /^https?:\/\//i.test(text);
    const isRootRelative = text.startsWith('/');

    if (!isHttp && !isRootRelative) {
        return '';
    }

    if (isRootRelative && text.length <= 1) {
        return '';
    }

    return text;
}

function parseStreamTitle(rawText) {
    if (!rawText) {
        return {};
    }

    let text = String(rawText).trim();

    const streamTitleMatch = text.match(/StreamTitle='([^']*)'/i);
    if (streamTitleMatch) {
        text = streamTitleMatch[1];
    } else if (text.toLowerCase().startsWith('streamtitle=')) {
        text = text.slice('StreamTitle='.length);
        text = text.replace(/^['"]?/, '').replace(/['"]?$/, '');
    }

    const streamUrlIndex = text.indexOf(';StreamUrl');
    if (streamUrlIndex !== -1) {
        text = text.substring(0, streamUrlIndex);
    }

    text = cleanMetadataValue(text);

    if (!text) {
        return {};
    }

    const parts = text.split(/\s+-\s+/);
    if (parts.length >= 2) {
        return {
            text,
            artist: parts[0].trim(),
            title: parts.slice(1).join(' - ').trim()
        };
    }

    return { text, title: text };
}

function cleanMetadataValue(value) {
    if (value === null || value === undefined) {
        return '';
    }

    let text = String(value).trim();

    if (!text) {
        return '';
    }

    const attributeOnlyMatch = text.match(/^\s*\w+=\s*(?:"([^"]*)"|'([^']*)'|(\S+))\s*$/);
    if (attributeOnlyMatch) {
        text = attributeOnlyMatch[1] || attributeOnlyMatch[2] || attributeOnlyMatch[3] || '';
    }

    const streamTitleMatch = text.match(/StreamTitle='([^']*)'/i);
    if (streamTitleMatch) {
        text = streamTitleMatch[1];
    }

    text = text.replace(/^StreamTitle=/i, '');
    text = text.replace(/;StreamUrl='[^']*';?/ig, '');
    text = text.replace(/;StreamUrl=[^;]*/ig, '');
    text = text.replace(/^['"]/, '').replace(/['"]$/, '');
    text = text.replace(/\+/g, ' ');

    const attributeValuePatterns = [
        /text="([^"]+)"/i,
        /title="([^"]+)"/i,
        /song="([^"]+)"/i,
        /artist="([^"]+)"/i,
        /album="([^"]+)"/i,
        /name="([^"]+)"/i,
        /description="([^"]+)"/i,
        /value="([^"]+)"/i
    ];

    for (const pattern of attributeValuePatterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
            text = match[1];
            break;
        }
    }

    if (/[&][a-z0-9#]+;/i.test(text)) {
        htmlEntityDecoder.innerHTML = text;
        text = htmlEntityDecoder.value;
    }

    text = text.replace(/<[^>]*>/g, ' ');
    text = text.replace(/https?:\/\/\S+/gi, ' ');
    text = text.replace(/www\.[^\s]+/gi, ' ');

    if (/%[0-9A-Fa-f]{2}/.test(text)) {
        try {
            text = decodeURIComponent(text);
        } catch (err) {
            // Ignore decoding errors and use the original value
        }
    }

    text = text.replace(/\s+\w+="[^"]*"/g, '');
    text = text.replace(/\s+\w+='[^']*'/g, '');
    text = text.replace(/\s+\w+=\S+/g, '');

    const streamMarkerIndex = text.search(/;\s*Stream/i);
    if (streamMarkerIndex !== -1) {
        text = text.substring(0, streamMarkerIndex);
    }

    text = text.replace(/[\s\-–—:]+$/, '');
    text = text.replace(/^[\s\-–—:]+/, '');
    text = text.replace(/\s+/g, ' ');

    return text.trim();
}

function collectStationIdentifiers(metadata, icyFields = {}) {
    const identifiers = new Set();
    const simplifiedIdentifiers = new Set();
    const tokenIdentifiers = new Set();
    const candidateValues = [
        metadata.icy_name,
        metadata.station_name,
        metadata.station_callsign,
        metadata.station_id,
        metadata.station,
        metadata.stream_name,
        metadata.stream_description,
        metadata.short_name,
        metadata.display_name,
        metadata.call_sign,
        metadata.callsign,
        metadata.source_name,
        metadata.device_name,
        metadata.icecast_server,
        metadata.icecast_mount,
        metadata.icecast_description,
        metadata.icecast_server_name,
        metadata.icecast_server_description,
        icyFields.name,
        icyFields.station,
        icyFields.server_name,
        icyFields.stream_description
    ];

    candidateValues.forEach(value => {
        const cleaned = cleanMetadataValue(value);
        if (cleaned) {
            const lower = cleaned.toLowerCase();
            identifiers.add(lower);
            const simplified = lower.replace(/[^a-z0-9]/g, '');
            if (simplified) {
                simplifiedIdentifiers.add(simplified);
            }
            lower.split(/[^a-z0-9]+/).filter(Boolean).forEach(token => {
                if (token.length >= 3) {
                    tokenIdentifiers.add(token);
                }
            });
        }
    });

    return {
        primary: identifiers,
        simplified: simplifiedIdentifiers,
        tokens: tokenIdentifiers
    };
}

function isMeaningfulMetadataValue(value, stationIdentifiers = { primary: new Set(), simplified: new Set(), tokens: new Set() }) {
    if (!value) {
        return false;
    }

    const text = value.trim();
    if (!text) {
        return false;
    }

    const lower = text.toLowerCase();

    const simplified = lower.replace(/[^a-z0-9]/g, '');

    if (stationIdentifiers.primary.has(lower) || (simplified && stationIdentifiers.simplified.has(simplified))) {
        return false;
    }

    for (const ident of stationIdentifiers.primary) {
        if (!ident || ident.length < 6) {
            continue;
        }
        if (lower.includes(ident) || ident.includes(lower)) {
            return false;
        }
        const identSimplified = ident.replace(/[^a-z0-9]/g, '');
        if (simplified && identSimplified && (identSimplified.includes(simplified) || simplified.includes(identSimplified))) {
            return false;
        }
    }

    if (stationIdentifiers.tokens.size) {
        const words = lower.split(/[^a-z0-9]+/).filter(Boolean);
        if (words.length) {
            const matches = words.filter(word => stationIdentifiers.tokens.has(word));
            if (matches.length >= 2 || (words.length === 1 && matches.length === 1)) {
                return false;
            }
            const coverage = matches.length / words.length;
            if (coverage >= 0.6) {
                return false;
            }
        }
    }

    const junkPatterns = [
        /^(listen\s+live|click\s+to\s+listen|tune\s+in)$/i,
        /streamtitle/i,
        /streamurl/i,
        /%[0-9a-f]{2}/i,
        /https?:/i,
        /onlineradiobox/i,
        /radio\.net/i,
        /iheart/i,
        /broadcaster/i,
        /digital\s+stream/i,
        /now\s+playing[:\-]?$/i,
        /listen\s*now/i
    ];

    if (junkPatterns.some(pattern => pattern.test(text))) {
        return false;
    }

    if (/^(n\/a|na|none|null|unknown)$/i.test(text)) {
        return false;
    }

    if (!/[a-z]/i.test(text) && !/[0-9]/.test(text)) {
        return false;
    }

    return true;
}

function escapeHtml(text) {
    if (text === null || text === undefined) return '';
    const div = document.createElement('div');
    div.textContent = String(text);
    return div.innerHTML;
}

async function startSource(sourceName) {
    try {
        const response = await fetch(`/api/audio/sources/${encodeURIComponent(sourceName)}/start`, {
            method: 'POST'
        });

        if (!response.ok) {
            const error = await response.json();
            alert(`Failed to start source: ${error.error || 'Unknown error'}`);
            return;
        }

        // Reload sources after a brief delay
        setTimeout(loadAudioSources, 1000);
    } catch (error) {
        console.error('Error starting source:', error);
        alert(`Error starting source: ${error.message}`);
    }
}

async function stopSource(sourceName) {
    try {
        const response = await fetch(`/api/audio/sources/${encodeURIComponent(sourceName)}/stop`, {
            method: 'POST'
        });

        if (!response.ok) {
            const error = await response.json();
            alert(`Failed to stop source: ${error.error || 'Unknown error'}`);
            return;
        }

        // Reload sources
        loadAudioSources();
    } catch (error) {
        console.error('Error stopping source:', error);
        alert(`Error stopping source: ${error.message}`);
    }
}

function updateLevelMetersFromSnapshot(snapshot) {
    if (!snapshot || !Array.isArray(snapshot.live_metrics)) {
        console.debug('No live_metrics in snapshot');
        return;
    }

    const now = Date.now();
    let updatedCount = 0;
    
    snapshot.live_metrics.forEach(metric => {
        const safeId = sanitizeId(metric.source_id);
        const peakBar = document.getElementById(`peak-meter-${safeId}`);
        const rmsBar = document.getElementById(`rms-meter-${safeId}`);
        const peakLabel = document.getElementById(`peak-label-${safeId}`);
        const rmsLabel = document.getElementById(`rms-label-${safeId}`);

        if (!peakBar) {
            console.debug(`VU meter elements not found for source_id: ${metric.source_id} (safeId: ${safeId})`);
            return;
        }

        // Get or initialize state for this meter
        let state = vuMeterState.get(metric.source_id);
        if (!state) {
            state = {
                lastPeak: metric.peak_level_db,
                lastRms: metric.rms_level_db,
                peakHold: metric.peak_level_db,
                peakHoldTime: now
            };
            vuMeterState.set(metric.source_id, state);
        }

        // Smooth peak value using exponential moving average
        // Peak rises quickly but falls slowly for realistic VU behavior
        // EMA formula: smoothed = old * (1 - alpha) + new * alpha
        // Higher alpha = more weight on new value = faster response
        const targetPeak = metric.peak_level_db;
        let smoothedPeak;
        if (targetPeak > state.lastPeak) {
            // Rise quickly (attack) - high alpha for fast response
            smoothedPeak = state.lastPeak * (1 - PEAK_ATTACK_SMOOTHING) + targetPeak * PEAK_ATTACK_SMOOTHING;
        } else {
            // Fall slowly (release) - low alpha for slow response
            smoothedPeak = state.lastPeak * (1 - PEAK_RELEASE_SMOOTHING) + targetPeak * PEAK_RELEASE_SMOOTHING;
        }

        // Update peak hold: hold the highest peak, reset after timeout
        if (targetPeak > state.peakHold) {
            // New peak is higher - update hold
            state.peakHold = targetPeak;
            state.peakHoldTime = now;
        } else if ((now - state.peakHoldTime) > PEAK_HOLD_TIME_MS) {
            // Hold time expired - reset to current level
            state.peakHold = targetPeak;
            state.peakHoldTime = now;
        }

        // Smooth RMS value using exponential moving average
        // RMS uses moderate smoothing for stable level indication
        const smoothedRms = state.lastRms * (1 - RMS_SMOOTHING) + metric.rms_level_db * RMS_SMOOTHING;

        // Update state
        state.lastPeak = smoothedPeak;
        state.lastRms = smoothedRms;

        // Apply to UI - peak shows current smoothed value
        const peakWidth = calculateFillWidth(smoothedPeak);
        peakBar.style.width = `${peakWidth}%`;
        peakBar.style.opacity = metric.source_status === 'running' ? 1 : 0.35;

        // RMS bar shows average level
        if (rmsBar) {
            const rmsWidth = calculateFillWidth(smoothedRms);
            rmsBar.style.width = `${rmsWidth}%`;
            rmsBar.style.opacity = metric.source_status === 'running' ? 0.9 : 0.3;
        }

        // Labels show raw server measurements, not client-side smoothed values
        if (peakLabel) {
            peakLabel.textContent = `Peak: ${formatDbLabel(metric.peak_level_db)}`;
        }
        if (rmsLabel) {
            rmsLabel.textContent = `RMS: ${formatDbLabel(metric.rms_level_db)}`;
        }
        updatedCount++;
    });

    console.debug(`Updated ${updatedCount} VU meters from ${snapshot.live_metrics.length} metrics`);
}

// ============================================================================
// EAS Monitor Status Functions
// ============================================================================

let easMonitorStartTime = null; // Track when monitor actually started

async function loadEASMonitorStatus() {
    try {
        const response = await fetch('/api/eas-monitor/status');
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        updateEASMonitorDisplay(data);
    } catch (error) {
        console.error('Failed to load EAS monitor status:', error);
        showEASMonitorError(`Failed to load status: ${error.message}`);
    }
}

function updateEASMonitorDisplay(status) {
    // Hide error if we got valid data
    const errorDiv = document.getElementById('eas-monitor-error');
    if (errorDiv) {
        errorDiv.classList.add('d-none');
    }

    // Update status badge
    const statusBadge = document.getElementById('eas-monitor-status-badge');
    const running = status.running || false;
    const audioFlowing = status.audio_flowing || false;

    if (statusBadge) {
        if (status.error) {
            statusBadge.innerHTML = '<span class="badge bg-danger">Error</span>';
            showEASMonitorError(status.error);
        } else if (running && audioFlowing) {
            statusBadge.innerHTML = '<span class="badge bg-success"><i class="fas fa-broadcast-tower"></i> Streaming</span>';
        } else if (running) {
            statusBadge.innerHTML = '<span class="badge bg-warning">Running (No Audio)</span>';
        } else {
            statusBadge.innerHTML = '<span class="badge bg-secondary">Stopped</span>';
        }
    }

    // Update running status
    const runningStatus = document.getElementById('eas-running-status');
    if (runningStatus) {
        runningStatus.textContent = running ? '✅ Active' : '⏸️ Stopped';
        runningStatus.style.color = running ? '#28a745' : '#6c757d';
    }

    // Update decoder health indicator
    const healthPct = ((status.health_percentage || 0) * 100).toFixed(1);
    const bufferBar = document.getElementById('eas-buffer-bar');
    const bufferText = document.getElementById('eas-buffer-text');
    const bufferPercentage = document.getElementById('eas-buffer-percentage');
    const bufferStatus = document.getElementById('eas-buffer-status');

    if (bufferBar) {
        bufferBar.style.width = `${healthPct}%`;
        bufferBar.setAttribute('aria-valuenow', healthPct);
        bufferBar.className = 'progress-bar progress-bar-striped';
        
        if (running) {
            bufferBar.classList.add('progress-bar-animated');
        }

        if (status.health_percentage >= 0.95) {
            bufferBar.classList.add('bg-success');
        } else if (status.health_percentage >= 0.8) {
            bufferBar.classList.add('bg-info');
        } else if (status.health_percentage > 0) {
            bufferBar.classList.add('bg-warning');
        } else {
            bufferBar.classList.add('bg-secondary');
        }
    }

    if (bufferText) {
        bufferText.textContent = `${healthPct}%`;
    }

    if (bufferPercentage) {
        bufferPercentage.textContent = `${healthPct}%`;
    }

    if (bufferStatus) {
        if (!running) {
            bufferStatus.innerHTML = '<i class="fas fa-pause-circle"></i> Decoder stopped';
            bufferStatus.className = 'text-muted d-block mt-1';
            easMonitorStartTime = null; // Reset start time when stopped
        } else if (!audioFlowing) {
            bufferStatus.innerHTML = '⚠️ No audio flowing';
            bufferStatus.className = 'text-warning d-block mt-1';
            easMonitorStartTime = null; // Reset if no audio
        } else {
            // Use server-side wall clock runtime if available for accurate warmup detection
            let actualRuntimeSeconds = status.wall_clock_runtime_seconds;
            
            // Determine if we're in warmup period
            // Server-provided runtime is most accurate, but fallback to client tracking if needed
            let isWarmingUp = false;
            if (actualRuntimeSeconds !== undefined && actualRuntimeSeconds !== null) {
                // Server provides wall clock runtime - use it directly
                isWarmingUp = actualRuntimeSeconds < EAS_WARMUP_DURATION_SECONDS;
            } else {
                // Fallback: track client-side for backward compatibility
                if (easMonitorStartTime === null) {
                    easMonitorStartTime = Date.now();
                    isWarmingUp = true; // Just started
                } else {
                    actualRuntimeSeconds = (Date.now() - easMonitorStartTime) / 1000;
                    isWarmingUp = actualRuntimeSeconds < EAS_WARMUP_DURATION_SECONDS;
                }
            }
            
            if (status.health_percentage >= 0.95) {
                const rate = status.sample_rate || 16000;
                const rateKhz = (rate / 1000).toFixed(2);
                bufferStatus.innerHTML = `✓ Processing at line rate (${rateKhz} kHz)`;
                bufferStatus.className = 'text-success d-block mt-1';
            } else if (isWarmingUp) {
                // Only show "warming up" during first 10 seconds after start
                bufferStatus.innerHTML = '<i class="fas fa-hourglass-half"></i> Warming up...';
                bufferStatus.className = 'text-info d-block mt-1';
            } else if (status.health_percentage >= 0.5) {
                // After warmup, if health is OK but not perfect, show it's working
                bufferStatus.innerHTML = `✓ Processing (${healthPct}% health)`;
                bufferStatus.className = 'text-info d-block mt-1';
            } else {
                // Below 50% health after warmup - show warning
                bufferStatus.innerHTML = '⚠️ Below expected rate';
                bufferStatus.className = 'text-warning d-block mt-1';
            }
        }
    }

    // Update samples processed
    const scansCount = document.getElementById('eas-scans-count');
    if (scansCount) {
        const samples = status.samples_processed || 0;
        if (samples > 1000000) {
            scansCount.textContent = `${(samples / 1000000).toFixed(1)}M`;
        } else if (samples > 1000) {
            scansCount.textContent = `${(samples / 1000).toFixed(1)}K`;
        } else {
            scansCount.textContent = samples.toLocaleString();
        }
    }

    const scansBreakdown = document.getElementById('eas-scans-breakdown');
    if (scansBreakdown) {
        // Use wall clock runtime for consistent display (doesn't fluctuate with sample rate)
        const runtime = status.wall_clock_runtime_seconds || status.runtime_seconds || 0;
        const hours = Math.floor(runtime / 3600);
        const minutes = Math.floor((runtime % 3600) / 60);
        const seconds = Math.floor(runtime % 60);
        if (hours > 0) {
            scansBreakdown.textContent = `Runtime: ${hours}h ${minutes}m`;
        } else if (minutes > 0) {
            scansBreakdown.textContent = `Runtime: ${minutes}m ${seconds}s`;
        } else {
            scansBreakdown.textContent = `Runtime: ${seconds}s`;
        }
    }

    // Update alerts detected
    const alertsCount = document.getElementById('eas-alerts-count');
    if (alertsCount) {
        const count = status.alerts_detected || 0;
        alertsCount.textContent = count.toLocaleString();
        alertsCount.style.color = count > 0 ? '#28a745' : '#6c757d';
    }

    // Update decoder status
    const activeScans = document.getElementById('eas-active-scans');
    if (activeScans) {
        if (status.decoder_in_message) {
            activeScans.innerHTML = '<span style="color: #dc3545;">🔴 Decoding Message</span>';
        } else if (status.decoder_synced) {
            activeScans.innerHTML = '<span style="color: #28a745;">🟢 Synced</span>';
        } else if (audioFlowing) {
            activeScans.innerHTML = '<span style="color: #6c757d;">⚪ Listening</span>';
        } else {
            activeScans.innerHTML = '<span style="color: #6c757d;">⏸️ Idle</span>';
        }
    }

    // Update streaming details
    const sampleRate = document.getElementById('eas-sample-rate');
    if (sampleRate) {
        const rate = status.sample_rate || 16000;
        sampleRate.textContent = `${(rate / 1000).toFixed(1)} kHz`;
    }

    const scanInterval = document.getElementById('eas-scan-interval');
    if (scanInterval) {
        const sps = status.samples_per_second || 0;
        if (sps > 0) {
            scanInterval.textContent = `${(sps / 1000).toFixed(1)}k samples/sec`;
        } else {
            scanInterval.textContent = '--';
        }
    }

    const scanOverlap = document.getElementById('eas-scan-overlap');
    if (scanOverlap) {
        // Use wall clock runtime for consistent display
        const runtime = status.wall_clock_runtime_seconds || status.runtime_seconds || 0;
        const hours = Math.floor(runtime / 3600);
        const minutes = Math.floor((runtime % 3600) / 60);
        if (hours > 0) {
            scanOverlap.textContent = `${hours}h ${minutes}m`;
        } else if (minutes > 0) {
            scanOverlap.textContent = `${minutes}m`;
        } else {
            scanOverlap.textContent = '< 1m';
        }
    }

    const bufferDuration = document.getElementById('eas-buffer-duration');
    if (bufferDuration) {
        const bytes = status.decoder_bytes_decoded || 0;
        bufferDuration.textContent = bytes.toLocaleString();
    }

    // Update last scan/alert times
    const lastScan = document.getElementById('eas-last-scan');
    if (lastScan) {
        if (status.decoder_synced) {
            lastScan.innerHTML = '<span style="color: #28a745;">✓ Yes</span>';
        } else {
            lastScan.innerHTML = '<span style="color: #6c757d;">No</span>';
        }
    }

    const lastAlert = document.getElementById('eas-last-alert');
    if (lastAlert && status.last_alert_time) {
        const alertTime = new Date(status.last_alert_time * 1000);
        const now = new Date();
        const diffMinutes = Math.floor((now - alertTime) / 60000);
        if (diffMinutes < 1) {
            lastAlert.textContent = 'Just now';
        } else if (diffMinutes < 60) {
            lastAlert.textContent = `${diffMinutes}m ago`;
        } else {
            const diffHours = Math.floor(diffMinutes / 60);
            lastAlert.textContent = `${diffHours}h ago`;
        }
        lastAlert.style.color = diffMinutes < 60 ? '#28a745' : '#6c757d';
    } else if (lastAlert) {
        lastAlert.textContent = 'Never';
        lastAlert.style.color = '#6c757d';
    }

    const scanWarnings = document.getElementById('eas-scan-warnings');
    if (scanWarnings) {
        if (status.decoder_in_message) {
            scanWarnings.innerHTML = '<span style="color: #dc3545;">Yes</span>';
        } else {
            scanWarnings.innerHTML = '<span style="color: #28a745;">No</span>';
        }
    }

    // Update streaming performance status message
    const performanceStatus = document.getElementById('performance-status');
    if (performanceStatus) {
        if (!running) {
            performanceStatus.textContent = 'Monitor stopped. Start monitoring to see real-time performance.';
            performanceStatus.style.color = '#6c757d';
        } else if (!audioFlowing) {
            performanceStatus.textContent = 'Waiting for audio data from sources. Configure and start audio sources to begin processing.';
            performanceStatus.style.color = '#856404';
        } else {
            // Audio is flowing - show processing rate
            const sps = status.samples_per_second || 0;
            const expectedRate = status.sample_rate || 16000;
            const percentage = expectedRate > 0 ? ((sps / expectedRate) * 100).toFixed(1) : 0;
            
            if (status.health_percentage >= 0.95) {
                performanceStatus.innerHTML = `<span style="color: #28a745;">✓ Processing at ${percentage}% of line rate (${(sps / 1000).toFixed(1)}k samples/sec). Real-time streaming active.</span>`;
            } else if (status.health_percentage >= 0.8) {
                performanceStatus.innerHTML = `<span style="color: #0c5460;">Processing at ${percentage}% of line rate (${(sps / 1000).toFixed(1)}k samples/sec). Building up to full rate...</span>`;
            } else {
                // Below 80% health - show warning
                performanceStatus.innerHTML = `<span style="color: #856404;">⚠️ Processing at ${percentage}% of expected rate (${(sps / 1000).toFixed(1)}k samples/sec). Check audio sources.</span>`;
            }
        }
    }
}

function showEASMonitorError(message) {
    const errorDiv = document.getElementById('eas-monitor-error');
    const errorMsg = document.getElementById('eas-monitor-error-message');

    if (errorDiv && errorMsg) {
        errorMsg.textContent = message;
        errorDiv.classList.remove('d-none');
    }
}

function formatTimeAgo(seconds) {
    if (seconds < 60) {
        return `${seconds}s ago`;
    } else if (seconds < 3600) {
        const mins = Math.floor(seconds / 60);
        return `${mins}m ago`;
    } else if (seconds < 86400) {
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        return `${hours}h ${mins}m ago`;
    } else {
        const days = Math.floor(seconds / 86400);
        return `${days}d ago`;
    }
}

async function controlEASMonitor(action) {
    try {
        const response = await fetch('/api/eas-monitor/control', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ action })
        });

        if (!response.ok) {
            const error = await response.json();
            alert(`Failed to ${action} monitor: ${error.error || 'Unknown error'}`);
            return;
        }

        const result = await response.json();

        if (result.success) {
            // Reload status after a brief delay
            setTimeout(loadEASMonitorStatus, 500);
        } else {
            alert(result.message || `Failed to ${action} monitor`);
        }
    } catch (error) {
        console.error(`Error ${action}ing EAS monitor:`, error);
        alert(`Error ${action}ing monitor: ${error.message}`);
    }
}

function connectAudioMonitoringSocket() {
    if (typeof io === 'undefined') {
        console.warn('Socket.IO client not available; skipping realtime updates');
        return;
    }

    if (audioMonitoringSocket) {
        audioMonitoringSocket.disconnect();
    }

    audioMonitoringSocket = io({
        transports: ['websocket', 'polling'],
        timeout: 5000
    });

    audioMonitoringSocket.on('connect', () => {
        console.info('Connected to audio monitoring WebSocket');
    });

    audioMonitoringSocket.on('audio_monitoring_update', payload => {
        if (payload?.audio_metrics) {
            updateLevelMetersFromSnapshot(payload.audio_metrics);
        }

        if (payload?.audio_sources) {
            updateAudioSourcesFromRealtime(payload.audio_sources);
        }

        if (payload?.eas_monitor) {
            updateEASMonitorDisplay(payload.eas_monitor);
        }
    });

    audioMonitoringSocket.on('disconnect', reason => {
        console.warn('Audio monitoring WebSocket disconnected:', reason);
    });
}

// Load sources on page load
document.addEventListener('DOMContentLoaded', function() {
    renderStreamModeControls();
    loadAudioSources(true); // Initial full render
    loadEASMonitorStatus();
    connectAudioMonitoringSocket();

    // Auto-refresh every 30 seconds - only updates metrics, never interrupts playback
    setInterval(() => loadAudioSources(false), 30000);
});

// Clean up intervals when page unloads
window.addEventListener('beforeunload', function() {
    if (audioMonitoringSocket) {
        audioMonitoringSocket.disconnect();
        audioMonitoringSocket = null;
    }
});
</script>
{% endblock %}
